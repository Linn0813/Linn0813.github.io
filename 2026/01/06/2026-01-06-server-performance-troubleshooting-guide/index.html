<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>🚀 服务器性能问题排查完全指南：从 OOM、CPU 高到压测配合，测试工程师必知必会 | Linn's Blog</title><meta name="author" content="yuxiaoling"><meta name="copyright" content="yuxiaoling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="系统解析服务器性能问题：从资源本质到问题排查，涵盖 OOM、CPU 高、异步处理、队列、锁等核心概念，帮助测试工程师理解性能问题的本质和排查思路。">
<meta property="og:type" content="article">
<meta property="og:title" content="🚀 服务器性能问题排查完全指南：从 OOM、CPU 高到压测配合，测试工程师必知必会">
<meta property="og:url" content="https://linn0813.github.io/2026/01/06/2026-01-06-server-performance-troubleshooting-guide/index.html">
<meta property="og:site_name" content="Linn&#39;s Blog">
<meta property="og:description" content="系统解析服务器性能问题：从资源本质到问题排查，涵盖 OOM、CPU 高、异步处理、队列、锁等核心概念，帮助测试工程师理解性能问题的本质和排查思路。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://linn0813.github.io/img/server-performance-guide.png">
<meta property="article:published_time" content="2026-01-06T12:00:00.000Z">
<meta property="article:modified_time" content="2026-01-21T04:03:44.640Z">
<meta property="article:author" content="yuxiaoling">
<meta property="article:tag" content="压测">
<meta property="article:tag" content="服务器性能">
<meta property="article:tag" content="OOM">
<meta property="article:tag" content="CPU">
<meta property="article:tag" content="异步处理">
<meta property="article:tag" content="资源管理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://linn0813.github.io/img/server-performance-guide.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "🚀 服务器性能问题排查完全指南：从 OOM、CPU 高到压测配合，测试工程师必知必会",
  "url": "https://linn0813.github.io/2026/01/06/2026-01-06-server-performance-troubleshooting-guide/",
  "image": "https://linn0813.github.io/img/server-performance-guide.png",
  "datePublished": "2026-01-06T12:00:00.000Z",
  "dateModified": "2026-01-21T04:03:44.640Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuxiaoling",
      "url": "https://linn0813.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://linn0813.github.io/2026/01/06/2026-01-06-server-performance-troubleshooting-guide/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="Xj7zV_DKnHFmJ7sXNRvdl5-UTfG4NLy-s7hDk1DZt4A"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":3,"unescape":true,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '🚀 服务器性能问题排查完全指南：从 OOM、CPU 高到压测配合，测试工程师必知必会',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/blog-enhancements.css"><meta name="msvalidate.01" content="C0AF818C725A2A1E112A1537E1064EA8" /><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/ loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">389</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa fa-comments"></i><span> 知识库问答</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/server-performance-guide.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/logo.jpg" alt="Logo" loading='lazy'><span class="site-name">Linn's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">🚀 服务器性能问题排查完全指南：从 OOM、CPU 高到压测配合，测试工程师必知必会</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/qa/"><i class="fa-fw fa fa-comments"></i><span> 知识库问答</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">🚀 服务器性能问题排查完全指南：从 OOM、CPU 高到压测配合，测试工程师必知必会</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2026-01-06T12:00:00.000Z" title="发表于 2026-01-06 20:00:00">2026-01-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2026-01-21T04:03:44.640Z" title="更新于 2026-01-21 12:03:44">2026-01-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%F0%9F%90%A7-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E9%98%B6%EF%BC%9ALinux-%E6%97%A5%E5%BF%97%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98/">🐧 服务端进阶：Linux 日志、性能与监控实战</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%F0%9F%90%A7-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BF%9B%E9%98%B6%EF%BC%9ALinux-%E6%97%A5%E5%BF%97%E3%80%81%E6%80%A7%E8%83%BD%E4%B8%8E%E7%9B%91%E6%8E%A7%E5%AE%9E%E6%88%98/%E5%BC%80%E5%8F%91%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%A0%88/">开发与技术栈</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>背景</strong>：最近遇到一个线上问题，运维反馈服务器出现 OOM、CPU 高的情况，需要压测配合排查。作为测试工程师，我发现自己对服务器性能问题缺乏系统认知，于是整理了这篇文档，希望能一次性讲清楚所有相关概念和排查思路。</p>
</blockquote>
<hr>
<h2 id="📋-目录概览"><a href="#📋-目录概览" class="headerlink" title="📋 目录概览"></a>📋 目录概览</h2><ol>
<li><a href="#1%EF%B8%8F%E2%83%A3-%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E7%9A%84%E6%9C%AC%E8%B4%A8">理解服务器资源的本质</a></li>
<li><a href="#2%EF%B8%8F%E2%83%A3-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%93%B6%E9%A2%88">性能问题的根源：资源竞争与瓶颈</a></li>
<li><a href="#3%EF%B8%8F%E2%83%A3-%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98oom-%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F">内存问题：OOM 与内存泄漏</a></li>
<li><a href="#4%EF%B8%8F%E2%83%A3-cpu-%E9%97%AE%E9%A2%98%E9%AB%98%E8%B4%9F%E8%BD%BD%E4%B8%8E%E6%AD%BB%E5%BE%AA%E7%8E%AF">CPU 问题：高负载与死循环</a></li>
<li><a href="#5%EF%B8%8F%E2%83%A3-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E5%BC%82%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8E%E9%94%81">并发处理机制：异步、队列与锁</a></li>
<li><a href="#6%EF%B8%8F%E2%83%A3-io-%E9%98%BB%E5%A1%9E%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AD%89%E5%BE%85">IO 阻塞与资源等待</a></li>
<li><a href="#7%EF%B8%8F%E2%83%A3-%E5%8E%8B%E6%B5%8B%E9%85%8D%E5%90%88%E6%8E%92%E6%9F%A5%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98">压测配合排查：如何定位问题</a></li>
<li><a href="#8%EF%B8%8F%E2%83%A3-%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">常见性能问题模式与解决方案</a></li>
<li><a href="#9%EF%B8%8F%E2%83%A3-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5">性能优化最佳实践</a></li>
</ol>
<hr>
<h2 id="1️⃣-理解服务器资源的本质"><a href="#1️⃣-理解服务器资源的本质" class="headerlink" title="1️⃣ 理解服务器资源的本质"></a>1️⃣ 理解服务器资源的本质</h2><p>在深入性能问题之前，我们需要理解服务器的三大核心资源：<strong>CPU、内存、IO</strong>。</p>
<h3 id="1-1-三大资源的本质"><a href="#1-1-三大资源的本质" class="headerlink" title="1.1 三大资源的本质"></a>1.1 三大资源的本质</h3><table>
<thead>
<tr>
<th>资源</th>
<th>本质</th>
<th>特点</th>
<th>限制因素</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CPU</strong></td>
<td>计算能力</td>
<td>有限的核心数，串行执行</td>
<td>核心数、主频</td>
</tr>
<tr>
<td><strong>内存</strong></td>
<td>临时存储空间</td>
<td>速度快但容量有限</td>
<td>容量大小</td>
</tr>
<tr>
<td><strong>IO</strong></td>
<td>数据输入输出</td>
<td>磁盘、网络读写</td>
<td>带宽、延迟</td>
</tr>
</tbody></table>
<h3 id="1-2-资源之间的关系"><a href="#1-2-资源之间的关系" class="headerlink" title="1.2 资源之间的关系"></a>1.2 资源之间的关系</h3><p><strong>资源竞争的本质</strong>：</p>
<ul>
<li>多个任务同时需要同一资源</li>
<li>资源有限，无法同时满足所有需求</li>
<li>导致任务排队等待，性能下降</li>
</ul>
<p><strong>资源依赖关系</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU 处理数据 → 需要从内存读取数据</span><br><span class="line">内存数据不足 → 需要从磁盘（IO）加载</span><br><span class="line">IO 操作慢 → CPU 等待，资源浪费</span><br></pre></td></tr></table></figure>

<p><strong>形象理解</strong>：</p>
<blockquote>
<p>想象一个餐厅：</p>
<ul>
<li><strong>CPU</strong> &#x3D; 厨师（处理能力有限）</li>
<li><strong>内存</strong> &#x3D; 工作台（空间有限）</li>
<li><strong>IO</strong> &#x3D; 食材仓库（取食材需要时间）</li>
</ul>
<p>如果工作台（内存）满了，厨师（CPU）无法继续工作；如果仓库（IO）太远，厨师需要等待食材，效率下降。</p>
</blockquote>
<hr>
<h2 id="2️⃣-性能问题的根源：资源竞争与瓶颈"><a href="#2️⃣-性能问题的根源：资源竞争与瓶颈" class="headerlink" title="2️⃣ 性能问题的根源：资源竞争与瓶颈"></a>2️⃣ 性能问题的根源：资源竞争与瓶颈</h2><h3 id="2-1-什么是性能问题？"><a href="#2-1-什么是性能问题？" class="headerlink" title="2.1 什么是性能问题？"></a>2.1 什么是性能问题？</h3><p><strong>性能问题的本质</strong>：系统无法在预期时间内完成预期任务。</p>
<p><strong>表现形式</strong>：</p>
<ul>
<li>响应时间变慢</li>
<li>吞吐量下降</li>
<li>错误率上升</li>
<li>资源耗尽（OOM、CPU 100%）</li>
</ul>
<h3 id="2-2-资源瓶颈的类型"><a href="#2-2-资源瓶颈的类型" class="headerlink" title="2.2 资源瓶颈的类型"></a>2.2 资源瓶颈的类型</h3><h4 id="2-2-1-CPU-瓶颈"><a href="#2-2-1-CPU-瓶颈" class="headerlink" title="2.2.1 CPU 瓶颈"></a>2.2.1 CPU 瓶颈</h4><p><strong>现象</strong>：</p>
<ul>
<li>CPU 使用率接近 100%</li>
<li>请求响应变慢</li>
<li>系统卡顿</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>死循环或无限递归</li>
<li>大量计算密集型任务</li>
<li>线程过多，上下文切换开销大</li>
<li>锁竞争激烈</li>
</ul>
<p><strong>排查思路</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 CPU 使用率</span></span><br><span class="line">top</span><br><span class="line">htop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 CPU 占用最高的进程</span></span><br><span class="line">ps aux --<span class="built_in">sort</span>=-%cpu | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看线程状态</span></span><br><span class="line">ps -eLf | grep &lt;进程名&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-内存瓶颈"><a href="#2-2-2-内存瓶颈" class="headerlink" title="2.2.2 内存瓶颈"></a>2.2.2 内存瓶颈</h4><p><strong>现象</strong>：</p>
<ul>
<li>内存使用率持续上升</li>
<li>OOM（Out of Memory）错误</li>
<li>系统开始使用 Swap（交换空间），性能急剧下降</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>内存泄漏（对象未释放）</li>
<li>缓存过大</li>
<li>大对象频繁创建</li>
<li>连接池未释放</li>
</ul>
<p><strong>排查思路</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看内存使用情况</span></span><br><span class="line">free -h</span><br><span class="line">top (按 M 键按内存排序)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程内存占用</span></span><br><span class="line">ps aux --<span class="built_in">sort</span>=-%mem | <span class="built_in">head</span> -10</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存泄漏（Java）</span></span><br><span class="line">jmap -histo &lt;pid&gt;</span><br><span class="line">jstat -gc &lt;pid&gt; 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内存泄漏（Python）</span></span><br><span class="line">memory_profiler</span><br><span class="line">py-spy</span><br></pre></td></tr></table></figure>

<h4 id="2-2-3-IO-瓶颈"><a href="#2-2-3-IO-瓶颈" class="headerlink" title="2.2.3 IO 瓶颈"></a>2.2.3 IO 瓶颈</h4><p><strong>现象</strong>：</p>
<ul>
<li>磁盘 IO 等待时间长</li>
<li>网络 IO 延迟高</li>
<li>数据库查询慢</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>磁盘读写频繁</li>
<li>网络带宽不足</li>
<li>数据库连接池耗尽</li>
<li>慢查询</li>
</ul>
<p><strong>排查思路</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看磁盘 IO</span></span><br><span class="line">iostat -x 1</span><br><span class="line">iotop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看网络 IO</span></span><br><span class="line">iftop</span><br><span class="line">netstat -an | grep ESTABLISHED | <span class="built_in">wc</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看数据库连接</span></span><br><span class="line">SHOW PROCESSLIST;</span><br><span class="line">SHOW STATUS LIKE <span class="string">&#x27;Threads_connected&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-资源瓶颈的连锁反应"><a href="#2-3-资源瓶颈的连锁反应" class="headerlink" title="2.3 资源瓶颈的连锁反应"></a>2.3 资源瓶颈的连锁反应</h3><p><strong>典型场景</strong>：内存不足 → 触发 OOM → 进程被杀死 → 请求失败 → CPU 处理错误 → 系统负载上升</p>
<p><strong>资源相互影响</strong>：</p>
<ul>
<li><strong>内存不足</strong>：系统使用 Swap，磁盘 IO 增加，CPU 等待 IO，整体性能下降</li>
<li><strong>CPU 高</strong>：处理变慢，请求堆积，内存占用增加（请求数据堆积）</li>
<li><strong>IO 慢</strong>：CPU 等待 IO，线程阻塞，内存中等待的请求增加</li>
</ul>
<hr>
<h2 id="3️⃣-内存问题：OOM-与内存泄漏"><a href="#3️⃣-内存问题：OOM-与内存泄漏" class="headerlink" title="3️⃣ 内存问题：OOM 与内存泄漏"></a>3️⃣ 内存问题：OOM 与内存泄漏</h2><h3 id="3-1-什么是-OOM？"><a href="#3-1-什么是-OOM？" class="headerlink" title="3.1 什么是 OOM？"></a>3.1 什么是 OOM？</h3><p><strong>OOM（Out of Memory）</strong>：内存溢出，系统无法分配足够的内存给进程。</p>
<p><strong>触发条件</strong>：</p>
<ul>
<li>进程申请的内存超过系统可用内存</li>
<li>系统内存不足，无法满足新请求</li>
</ul>
<p><strong>OOM Killer</strong>：</p>
<ul>
<li>Linux 系统在内存不足时会触发 OOM Killer</li>
<li>自动杀死占用内存最多的进程</li>
<li>保证系统核心功能正常运行</li>
</ul>
<h3 id="3-2-OOM-的常见场景"><a href="#3-2-OOM-的常见场景" class="headerlink" title="3.2 OOM 的常见场景"></a>3.2 OOM 的常见场景</h3><h4 id="场景-1：内存泄漏"><a href="#场景-1：内存泄漏" class="headerlink" title="场景 1：内存泄漏"></a>场景 1：内存泄漏</h4><p><strong>问题</strong>：对象创建后未释放，内存持续增长</p>
<p><strong>示例（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：全局列表不断增长，永不释放</span></span><br><span class="line">cache = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">data</span>):</span><br><span class="line">    cache.append(data)  <span class="comment"># 内存泄漏！</span></span><br><span class="line">    <span class="keyword">return</span> process(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：使用 LRU 缓存，限制大小</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">1000</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="keyword">return</span> process(data)</span><br></pre></td></tr></table></figure>

<p><strong>示例（Java）</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ❌ 错误：静态集合不断增长</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; cache = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">    cache.add(data);  <span class="comment">// 内存泄漏！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ✅ 正确：使用有界集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_SIZE</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; cache = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(MAX_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">processRequest</span><span class="params">(Object data)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cache.size() &gt;= MAX_SIZE) &#123;</span><br><span class="line">        cache.remove(<span class="number">0</span>);  <span class="comment">// 移除最老的</span></span><br><span class="line">    &#125;</span><br><span class="line">    cache.add(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="场景-2：大对象频繁创建"><a href="#场景-2：大对象频繁创建" class="headerlink" title="场景 2：大对象频繁创建"></a>场景 2：大对象频繁创建</h4><p><strong>问题</strong>：每次请求都创建大对象，GC 来不及回收</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：每次请求都创建大对象</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_request</span>():</span><br><span class="line">    large_data = load_large_file()  <span class="comment"># 100MB</span></span><br><span class="line">    <span class="keyword">return</span> process(large_data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：对象池或缓存</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_large_data</span>():</span><br><span class="line">    <span class="keyword">return</span> load_large_file()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">handle_request</span>():</span><br><span class="line">    large_data = get_large_data()  <span class="comment"># 复用</span></span><br><span class="line">    <span class="keyword">return</span> process(large_data)</span><br></pre></td></tr></table></figure>

<h4 id="场景-3：连接池未释放"><a href="#场景-3：连接池未释放" class="headerlink" title="场景 3：连接池未释放"></a>场景 3：连接池未释放</h4><p><strong>问题</strong>：数据库连接、HTTP 连接未关闭，连接数持续增长</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：连接未关闭</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_database</span>():</span><br><span class="line">    conn = pymysql.connect(...)</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    result = cursor.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line">    <span class="comment"># 忘记关闭连接！</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：使用上下文管理器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_database</span>():</span><br><span class="line">    <span class="keyword">with</span> pymysql.connect(...) <span class="keyword">as</span> conn:</span><br><span class="line">        <span class="keyword">with</span> conn.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">            result = cursor.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 自动关闭连接</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-内存泄漏的排查方法"><a href="#3-3-内存泄漏的排查方法" class="headerlink" title="3.3 内存泄漏的排查方法"></a>3.3 内存泄漏的排查方法</h3><h4 id="方法-1：监控内存趋势"><a href="#方法-1：监控内存趋势" class="headerlink" title="方法 1：监控内存趋势"></a>方法 1：监控内存趋势</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 持续监控内存使用</span></span><br><span class="line">watch -n 1 <span class="string">&#x27;free -h&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看进程内存增长趋势</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span></span><br><span class="line">    ps aux | grep &lt;进程名&gt; | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br><span class="line">    <span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-2：使用内存分析工具"><a href="#方法-2：使用内存分析工具" class="headerlink" title="方法 2：使用内存分析工具"></a>方法 2：使用内存分析工具</h4><p><strong>Java</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成堆转储</span></span><br><span class="line">jmap -dump:format=b,file=heap.hprof &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 Eclipse MAT 或 VisualVM 分析</span></span><br></pre></td></tr></table></figure>

<p><strong>Python</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 memory_profiler</span></span><br><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"></span><br><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="comment"># 代码</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-3：压测配合排查"><a href="#方法-3：压测配合排查" class="headerlink" title="方法 3：压测配合排查"></a>方法 3：压测配合排查</h4><p><strong>步骤</strong>：</p>
<ol>
<li><strong>基线测试</strong>：记录正常情况下的内存使用</li>
<li><strong>逐步加压</strong>：逐步增加并发数，观察内存变化</li>
<li><strong>稳定压力</strong>：保持稳定压力，观察内存是否持续增长</li>
<li><strong>停止压测</strong>：停止压测后，观察内存是否回落</li>
</ol>
<p><strong>判断标准</strong>：</p>
<ul>
<li>✅ <strong>正常</strong>：压测停止后，内存回落</li>
<li>❌ <strong>内存泄漏</strong>：压测停止后，内存不回落或持续增长</li>
</ul>
<hr>
<h2 id="4️⃣-CPU-问题：高负载与死循环"><a href="#4️⃣-CPU-问题：高负载与死循环" class="headerlink" title="4️⃣ CPU 问题：高负载与死循环"></a>4️⃣ CPU 问题：高负载与死循环</h2><h3 id="4-1-CPU-高负载的原因"><a href="#4-1-CPU-高负载的原因" class="headerlink" title="4.1 CPU 高负载的原因"></a>4.1 CPU 高负载的原因</h3><h4 id="原因-1：死循环或无限递归"><a href="#原因-1：死循环或无限递归" class="headerlink" title="原因 1：死循环或无限递归"></a>原因 1：死循环或无限递归</h4><p><strong>问题</strong>：代码逻辑错误，导致 CPU 持续 100% 占用</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：死循环</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 缺少退出条件！</span></span><br><span class="line">        data = get_data()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 如果 get_data() 总是返回数据，永远不会退出</span></span><br><span class="line">        process(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：添加超时或限制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>():</span><br><span class="line">    max_iterations = <span class="number">1000</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; max_iterations:</span><br><span class="line">        data = get_data()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        process(data)</span><br><span class="line">        count += <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="原因-2：大量计算密集型任务"><a href="#原因-2：大量计算密集型任务" class="headerlink" title="原因 2：大量计算密集型任务"></a>原因 2：大量计算密集型任务</h4><p><strong>问题</strong>：CPU 密集型任务占用过多 CPU 资源</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>异步处理</strong>：将计算任务放到后台线程</li>
<li><strong>限流</strong>：限制并发计算任务数</li>
<li><strong>缓存</strong>：避免重复计算</li>
</ul>
<h4 id="原因-3：线程过多"><a href="#原因-3：线程过多" class="headerlink" title="原因 3：线程过多"></a>原因 3：线程过多</h4><p><strong>问题</strong>：线程数超过 CPU 核心数，上下文切换开销大</p>
<p><strong>计算线程数的经验公式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">最佳线程数 = CPU 核心数 × (1 + IO 等待时间 / CPU 计算时间)</span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<ul>
<li>CPU 核心数：8</li>
<li>IO 等待时间：50ms</li>
<li>CPU 计算时间：10ms</li>
<li><strong>最佳线程数</strong> &#x3D; 8 × (1 + 50&#x2F;10) &#x3D; 48</li>
</ul>
<p><strong>如果线程数过多</strong>：</p>
<ul>
<li>上下文切换开销增加</li>
<li>CPU 缓存命中率下降</li>
<li>整体性能下降</li>
</ul>
<h3 id="4-2-CPU-问题的排查方法"><a href="#4-2-CPU-问题的排查方法" class="headerlink" title="4.2 CPU 问题的排查方法"></a>4.2 CPU 问题的排查方法</h3><h4 id="方法-1：定位-CPU-占用最高的线程"><a href="#方法-1：定位-CPU-占用最高的线程" class="headerlink" title="方法 1：定位 CPU 占用最高的线程"></a>方法 1：定位 CPU 占用最高的线程</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 CPU 占用最高的进程</span></span><br><span class="line">top -H -p &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看线程详细信息</span></span><br><span class="line">ps -eLf | grep &lt;进程名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Java 应用：查看线程栈</span></span><br><span class="line">jstack &lt;pid&gt; | grep -A 10 <span class="string">&quot;cpu&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="方法-2：分析线程栈"><a href="#方法-2：分析线程栈" class="headerlink" title="方法 2：分析线程栈"></a>方法 2：分析线程栈</h4><p><strong>Java</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成线程转储</span></span><br><span class="line">jstack &lt;pid&gt; &gt; thread_dump.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 CPU 占用高的线程</span></span><br><span class="line">top -H -p &lt;pid&gt;  <span class="comment"># 获取线程 ID（十进制）</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x\n&quot;</span> &lt;线程ID&gt;  <span class="comment"># 转换为十六进制</span></span><br><span class="line">jstack &lt;pid&gt; | grep -A 10 &lt;十六进制线程ID&gt;</span><br></pre></td></tr></table></figure>

<p><strong>Python</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 py-spy 分析</span></span><br><span class="line">py-spy top --pid &lt;pid&gt;</span><br><span class="line">py-spy record -o profile.svg --pid &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<h4 id="方法-3：压测配合排查-1"><a href="#方法-3：压测配合排查-1" class="headerlink" title="方法 3：压测配合排查"></a>方法 3：压测配合排查</h4><p><strong>步骤</strong>：</p>
<ol>
<li><strong>基线测试</strong>：记录正常情况下的 CPU 使用率</li>
<li><strong>逐步加压</strong>：逐步增加并发数，观察 CPU 变化</li>
<li><strong>定位热点</strong>：使用性能分析工具定位 CPU 热点代码</li>
<li><strong>优化验证</strong>：优化后再次压测验证</li>
</ol>
<hr>
<h2 id="5️⃣-并发处理机制：异步、队列与锁"><a href="#5️⃣-并发处理机制：异步、队列与锁" class="headerlink" title="5️⃣ 并发处理机制：异步、队列与锁"></a>5️⃣ 并发处理机制：异步、队列与锁</h2><h3 id="5-1-为什么需要并发处理？"><a href="#5-1-为什么需要并发处理？" class="headerlink" title="5.1 为什么需要并发处理？"></a>5.1 为什么需要并发处理？</h3><p><strong>问题场景</strong>：</p>
<ul>
<li>单线程处理：一个请求处理完才能处理下一个，效率低</li>
<li>多线程处理：可以同时处理多个请求，但资源竞争问题</li>
</ul>
<p><strong>并发处理的本质</strong>：在有限的资源下，最大化资源利用率。</p>
<h3 id="5-2-异步处理（Async）"><a href="#5-2-异步处理（Async）" class="headerlink" title="5.2 异步处理（Async）"></a>5.2 异步处理（Async）</h3><h4 id="5-2-1-什么是异步？"><a href="#5-2-1-什么是异步？" class="headerlink" title="5.2.1 什么是异步？"></a>5.2.1 什么是异步？</h4><p><strong>同步 vs 异步</strong>：</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>特点</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>同步</strong></td>
<td>等待操作完成才继续</td>
<td>调用 API，等待响应</td>
</tr>
<tr>
<td><strong>异步</strong></td>
<td>不等待操作完成，继续执行</td>
<td>调用 API，立即返回，回调处理结果</td>
</tr>
</tbody></table>
<p><strong>形象理解</strong>：</p>
<blockquote>
<p><strong>同步</strong>：你去餐厅点餐，站在柜台前等待，直到拿到餐才离开<br><strong>异步</strong>：你去餐厅点餐，拿到号码牌后去座位等待，餐好了服务员通知你</p>
</blockquote>
<h4 id="5-2-2-异步的优势"><a href="#5-2-2-异步的优势" class="headerlink" title="5.2.2 异步的优势"></a>5.2.2 异步的优势</h4><p><strong>优势</strong>：</p>
<ul>
<li><strong>提高吞吐量</strong>：不阻塞等待，可以处理更多请求</li>
<li><strong>资源利用率高</strong>：IO 等待时，CPU 可以处理其他任务</li>
<li><strong>响应更快</strong>：不需要等待慢操作完成</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>IO 密集型操作（数据库查询、API 调用、文件读写）</li>
<li>不需要立即返回结果的操作</li>
</ul>
<p><strong>不适用场景</strong>：</p>
<ul>
<li>CPU 密集型操作（会阻塞事件循环）</li>
<li>需要立即返回结果的操作</li>
</ul>
<h4 id="5-2-3-异步的实现方式"><a href="#5-2-3-异步的实现方式" class="headerlink" title="5.2.3 异步的实现方式"></a>5.2.3 异步的实现方式</h4><p><strong>Python（asyncio）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 异步处理多个请求</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_url</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;http://example.com&#x27;</span>] * <span class="number">100</span></span><br><span class="line">    tasks = [fetch_url(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><strong>Java（CompletableFuture）</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ✅ 异步处理</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> fetchData();  <span class="comment">// 异步执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">future.thenAccept(result -&gt; &#123;</span><br><span class="line">    <span class="comment">// 处理结果</span></span><br><span class="line">    processResult(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-3-队列（Queue）"><a href="#5-3-队列（Queue）" class="headerlink" title="5.3 队列（Queue）"></a>5.3 队列（Queue）</h3><h4 id="5-3-1-什么是队列？"><a href="#5-3-1-什么是队列？" class="headerlink" title="5.3.1 什么是队列？"></a>5.3.1 什么是队列？</h4><p><strong>队列的本质</strong>：缓冲和调度机制，解决生产者和消费者速度不匹配的问题。</p>
<p><strong>队列的作用</strong>：</p>
<ul>
<li><strong>缓冲</strong>：临时存储待处理的任务</li>
<li><strong>削峰</strong>：高峰期请求先入队，后台慢慢处理</li>
<li><strong>解耦</strong>：生产者和消费者不需要直接交互</li>
</ul>
<p><strong>形象理解</strong>：</p>
<blockquote>
<p>队列就像餐厅的排队系统：</p>
<ul>
<li>客人（生产者）到达后排队</li>
<li>服务员（消费者）按顺序处理</li>
<li>如果处理不过来，客人排队等待</li>
</ul>
</blockquote>
<h4 id="5-3-2-队列的类型"><a href="#5-3-2-队列的类型" class="headerlink" title="5.3.2 队列的类型"></a>5.3.2 队列的类型</h4><p><strong>1. 同步队列（Blocking Queue）</strong></p>
<p><strong>特点</strong>：队列满时，生产者阻塞；队列空时，消费者阻塞</p>
<p><strong>示例（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建队列</span></span><br><span class="line">task_queue = Queue(maxsize=<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者：添加任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        task_queue.put(i)  <span class="comment"># 队列满时会阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者：处理任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        task = task_queue.get()  <span class="comment"># 队列空时会阻塞</span></span><br><span class="line">        process_task(task)</span><br><span class="line">        task_queue.task_done()</span><br></pre></td></tr></table></figure>

<p><strong>2. 异步队列（Async Queue）</strong></p>
<p><strong>特点</strong>：非阻塞，使用协程处理</p>
<p><strong>示例（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        <span class="keyword">await</span> queue.put(i)  <span class="comment"># 非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">queue</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        task = <span class="keyword">await</span> queue.get()  <span class="comment"># 非阻塞</span></span><br><span class="line">        <span class="keyword">await</span> process_task(task)</span><br><span class="line">        queue.task_done()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行</span></span><br><span class="line">queue = asyncio.Queue(maxsize=<span class="number">100</span>)</span><br><span class="line"><span class="keyword">await</span> asyncio.gather(</span><br><span class="line">    producer(queue),</span><br><span class="line">    consumer(queue)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>3. 消息队列（Message Queue）</strong></p>
<p><strong>特点</strong>：分布式、持久化、支持多消费者</p>
<p><strong>常见实现</strong>：</p>
<ul>
<li><strong>Redis</strong>：简单快速，适合小规模</li>
<li><strong>RabbitMQ</strong>：功能完整，适合复杂场景</li>
<li><strong>Kafka</strong>：高吞吐，适合大数据场景</li>
</ul>
<p><strong>示例（Redis）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接 Redis</span></span><br><span class="line">r = redis.Redis(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产者：推送任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>():</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        r.lpush(<span class="string">&#x27;task_queue&#x27;</span>, i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费者：处理任务</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        task = r.brpop(<span class="string">&#x27;task_queue&#x27;</span>, timeout=<span class="number">1</span>)  <span class="comment"># 阻塞等待</span></span><br><span class="line">        <span class="keyword">if</span> task:</span><br><span class="line">            process_task(task[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h4 id="5-3-3-队列的使用场景"><a href="#5-3-3-队列的使用场景" class="headerlink" title="5.3.3 队列的使用场景"></a>5.3.3 队列的使用场景</h4><p><strong>场景 1：削峰填谷</strong></p>
<p><strong>问题</strong>：高峰期请求量大，直接处理会导致系统崩溃</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求 → 队列 → 后台处理</span><br><span class="line">高峰期：请求入队，不立即处理</span><br><span class="line">低峰期：队列中的任务慢慢处理</span><br></pre></td></tr></table></figure>

<p><strong>场景 2：异步任务处理</strong></p>
<p><strong>问题</strong>：某些任务不需要立即返回结果（如发送邮件、生成报表）</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户请求 → 立即返回 → 任务入队 → 后台处理</span><br></pre></td></tr></table></figure>

<p><strong>场景 3：解耦系统</strong></p>
<p><strong>问题</strong>：系统 A 需要通知系统 B，但不想直接耦合</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">系统 A → 消息队列 → 系统 B</span><br></pre></td></tr></table></figure>

<h3 id="5-4-锁（Lock）"><a href="#5-4-锁（Lock）" class="headerlink" title="5.4 锁（Lock）"></a>5.4 锁（Lock）</h3><h4 id="5-4-1-为什么需要锁？"><a href="#5-4-1-为什么需要锁？" class="headerlink" title="5.4.1 为什么需要锁？"></a>5.4.1 为什么需要锁？</h4><p><strong>问题场景</strong>：多个线程同时访问共享资源，可能导致数据不一致</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ❌ 问题：多线程同时修改共享变量</span></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        counter += <span class="number">1</span>  <span class="comment"># 不是原子操作！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个线程同时执行 increment()</span></span><br><span class="line"><span class="comment"># 预期结果：counter = 200000</span></span><br><span class="line"><span class="comment"># 实际结果：counter &lt; 200000（数据竞争）</span></span><br></pre></td></tr></table></figure>

<p><strong>锁的作用</strong>：保证同一时间只有一个线程访问共享资源</p>
<h4 id="5-4-2-锁的类型"><a href="#5-4-2-锁的类型" class="headerlink" title="5.4.2 锁的类型"></a>5.4.2 锁的类型</h4><p><strong>1. 互斥锁（Mutex Lock）</strong></p>
<p><strong>特点</strong>：同一时间只有一个线程可以获取锁</p>
<p><strong>示例（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">lock = threading.Lock()</span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        <span class="keyword">with</span> lock:  <span class="comment"># 获取锁</span></span><br><span class="line">            counter += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 自动释放锁</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 读写锁（Read-Write Lock）</strong></p>
<p><strong>特点</strong>：多个读操作可以并发，写操作独占</p>
<p><strong>适用场景</strong>：读多写少的场景</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReadWriteLock</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>._read_lock = threading.Lock()</span><br><span class="line">        <span class="variable language_">self</span>._write_lock = threading.Lock()</span><br><span class="line">        <span class="variable language_">self</span>._readers = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">acquire_read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>._read_lock:</span><br><span class="line">            <span class="variable language_">self</span>._readers += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._readers == <span class="number">1</span>:</span><br><span class="line">                <span class="variable language_">self</span>._write_lock.acquire()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">release_read</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="variable language_">self</span>._read_lock:</span><br><span class="line">            <span class="variable language_">self</span>._readers -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> <span class="variable language_">self</span>._readers == <span class="number">0</span>:</span><br><span class="line">                <span class="variable language_">self</span>._write_lock.release()</span><br></pre></td></tr></table></figure>

<p><strong>3. 分布式锁</strong></p>
<p><strong>特点</strong>：跨进程、跨服务器的锁</p>
<p><strong>实现方式</strong>：</p>
<ul>
<li><strong>Redis</strong>：使用 SETNX 命令</li>
<li><strong>Zookeeper</strong>：使用临时节点</li>
<li><strong>数据库</strong>：使用唯一索引</li>
</ul>
<p><strong>示例（Redis）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">acquire_lock</span>(<span class="params">conn, lock_name, timeout=<span class="number">10</span></span>):</span><br><span class="line">    identifier = <span class="built_in">str</span>(time.time())</span><br><span class="line">    end = time.time() + timeout</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> time.time() &lt; end:</span><br><span class="line">        <span class="keyword">if</span> conn.setnx(<span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span>, identifier):</span><br><span class="line">            conn.expire(<span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span>, timeout)</span><br><span class="line">            <span class="keyword">return</span> identifier</span><br><span class="line">        time.sleep(<span class="number">0.001</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">release_lock</span>(<span class="params">conn, lock_name, identifier</span>):</span><br><span class="line">    pipe = conn.pipeline(<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pipe.watch(<span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> pipe.get(<span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span>) == identifier:</span><br><span class="line">                pipe.multi()</span><br><span class="line">                pipe.delete(<span class="string">f&#x27;lock:<span class="subst">&#123;lock_name&#125;</span>&#x27;</span>)</span><br><span class="line">                pipe.execute()</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            pipe.unwatch()</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> redis.WatchError:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="5-4-3-锁的常见问题"><a href="#5-4-3-锁的常见问题" class="headerlink" title="5.4.3 锁的常见问题"></a>5.4.3 锁的常见问题</h4><p><strong>问题 1：死锁</strong></p>
<p><strong>场景</strong>：两个线程互相等待对方释放锁</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ❌ 死锁示例</span></span><br><span class="line">lock1 = threading.Lock()</span><br><span class="line">lock2 = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread1</span>():</span><br><span class="line">    lock1.acquire()</span><br><span class="line">    lock2.acquire()  <span class="comment"># 等待 lock2</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    lock2.release()</span><br><span class="line">    lock1.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">thread2</span>():</span><br><span class="line">    lock2.acquire()</span><br><span class="line">    lock1.acquire()  <span class="comment"># 等待 lock1（死锁！）</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line">    lock1.release()</span><br><span class="line">    lock2.release()</span><br></pre></td></tr></table></figure>

<p><strong>解决方案</strong>：</p>
<ul>
<li>按固定顺序获取锁</li>
<li>使用超时机制</li>
<li>避免嵌套锁</li>
</ul>
<p><strong>问题 2：锁竞争激烈</strong></p>
<p><strong>问题</strong>：太多线程竞争同一把锁，导致性能下降</p>
<p><strong>解决方案</strong>：</p>
<ul>
<li><strong>减少锁的粒度</strong>：只锁必要的代码段</li>
<li><strong>使用无锁数据结构</strong>：如原子操作</li>
<li><strong>使用读写锁</strong>：读操作不互斥</li>
</ul>
<hr>
<h2 id="6️⃣-IO-阻塞与资源等待"><a href="#6️⃣-IO-阻塞与资源等待" class="headerlink" title="6️⃣ IO 阻塞与资源等待"></a>6️⃣ IO 阻塞与资源等待</h2><h3 id="6-1-IO-阻塞的本质"><a href="#6-1-IO-阻塞的本质" class="headerlink" title="6.1 IO 阻塞的本质"></a>6.1 IO 阻塞的本质</h3><p><strong>IO 阻塞</strong>：线程等待 IO 操作完成，期间无法处理其他任务</p>
<p><strong>阻塞时间</strong>：</p>
<ul>
<li><strong>磁盘 IO</strong>：毫秒级（1-10ms）</li>
<li><strong>网络 IO</strong>：毫秒到秒级（10ms-10s）</li>
<li><strong>数据库查询</strong>：毫秒到秒级（10ms-10s）</li>
</ul>
<p><strong>问题</strong>：阻塞期间，线程无法处理其他请求，资源浪费</p>
<h3 id="6-2-IO-阻塞的解决方案"><a href="#6-2-IO-阻塞的解决方案" class="headerlink" title="6.2 IO 阻塞的解决方案"></a>6.2 IO 阻塞的解决方案</h3><h4 id="方案-1：异步-IO"><a href="#方案-1：异步-IO" class="headerlink" title="方案 1：异步 IO"></a>方案 1：异步 IO</h4><p><strong>原理</strong>：IO 操作不阻塞线程，使用回调或协程处理结果</p>
<p><strong>示例（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> aiohttp</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.text()  <span class="comment"># 非阻塞</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以同时处理多个 IO 操作</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    urls = [<span class="string">&#x27;http://example.com&#x27;</span>] * <span class="number">100</span></span><br><span class="line">    tasks = [fetch_data(url) <span class="keyword">for</span> url <span class="keyword">in</span> urls]</span><br><span class="line">    results = <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line">    <span class="keyword">return</span> results</span><br></pre></td></tr></table></figure>

<h4 id="方案-2：连接池"><a href="#方案-2：连接池" class="headerlink" title="方案 2：连接池"></a>方案 2：连接池</h4><p><strong>原理</strong>：复用连接，减少连接建立和关闭的开销</p>
<p><strong>示例（Python）</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接池</span></span><br><span class="line">pool = pymysql.ConnectionPool(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;password&#x27;</span>,</span><br><span class="line">    database=<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">    maxconnections=<span class="number">10</span>  <span class="comment"># 最大连接数</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_connection</span>():</span><br><span class="line">    conn = pool.get_connection()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> conn</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        pool.release_connection(conn)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用连接池</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">query_database</span>():</span><br><span class="line">    <span class="keyword">with</span> get_connection() <span class="keyword">as</span> conn:</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> cursor.fetchall()</span><br></pre></td></tr></table></figure>

<h4 id="方案-3：批量处理"><a href="#方案-3：批量处理" class="headerlink" title="方案 3：批量处理"></a>方案 3：批量处理</h4><p><strong>原理</strong>：减少 IO 次数，提高效率</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ❌ 错误：逐个查询</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_users</span>(<span class="params">user_ids</span>):</span><br><span class="line">    results = []</span><br><span class="line">    <span class="keyword">for</span> user_id <span class="keyword">in</span> user_ids:</span><br><span class="line">        user = query_user(user_id)  <span class="comment"># 100 次数据库查询</span></span><br><span class="line">        results.append(user)</span><br><span class="line">    <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 正确：批量查询</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_users</span>(<span class="params">user_ids</span>):</span><br><span class="line">    users = batch_query_users(user_ids)  <span class="comment"># 1 次数据库查询</span></span><br><span class="line">    <span class="keyword">return</span> users</span><br></pre></td></tr></table></figure>

<h3 id="6-3-资源等待的优化"><a href="#6-3-资源等待的优化" class="headerlink" title="6.3 资源等待的优化"></a>6.3 资源等待的优化</h3><h4 id="优化-1：超时机制"><a href="#优化-1：超时机制" class="headerlink" title="优化 1：超时机制"></a>优化 1：超时机制</h4><p><strong>问题</strong>：资源等待时间过长，影响用户体验</p>
<p><strong>解决方案</strong>：设置超时时间</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置超时</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;http://example.com&#x27;</span>, timeout=<span class="number">5</span>)  <span class="comment"># 5 秒超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据库查询超时</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>, timeout=<span class="number">10</span>)  <span class="comment"># 10 秒超时</span></span><br></pre></td></tr></table></figure>

<h4 id="优化-2：重试机制"><a href="#优化-2：重试机制" class="headerlink" title="优化 2：重试机制"></a>优化 2：重试机制</h4><p><strong>问题</strong>：临时故障导致请求失败</p>
<p><strong>解决方案</strong>：失败后重试</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">retry</span>(<span class="params">max_attempts=<span class="number">3</span>, delay=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">        @wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> attempt <span class="keyword">in</span> <span class="built_in">range</span>(max_attempts):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">if</span> attempt == max_attempts - <span class="number">1</span>:</span><br><span class="line">                        <span class="keyword">raise</span></span><br><span class="line">                    time.sleep(delay)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@retry(<span class="params">max_attempts=<span class="number">3</span>, delay=<span class="number">1</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    response = requests.get(url, timeout=<span class="number">5</span>)</span><br><span class="line">    response.raise_for_status()</span><br><span class="line">    <span class="keyword">return</span> response.json()</span><br></pre></td></tr></table></figure>

<h4 id="优化-3：缓存"><a href="#优化-3：缓存" class="headerlink" title="优化 3：缓存"></a>优化 3：缓存</h4><p><strong>问题</strong>：重复查询相同数据</p>
<p><strong>解决方案</strong>：缓存查询结果</p>
<p><strong>示例</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存缓存</span></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">1000</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user</span>(<span class="params">user_id</span>):</span><br><span class="line">    <span class="keyword">return</span> query_user(user_id)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis 缓存</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_user_cached</span>(<span class="params">user_id</span>):</span><br><span class="line">    cache_key = <span class="string">f&#x27;user:<span class="subst">&#123;user_id&#125;</span>&#x27;</span></span><br><span class="line">    cached = redis_client.get(cache_key)</span><br><span class="line">    <span class="keyword">if</span> cached:</span><br><span class="line">        <span class="keyword">return</span> json.loads(cached)</span><br><span class="line">    </span><br><span class="line">    user = query_user(user_id)</span><br><span class="line">    redis_client.setex(cache_key, <span class="number">3600</span>, json.dumps(user))  <span class="comment"># 缓存 1 小时</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7️⃣-压测配合排查：如何定位问题"><a href="#7️⃣-压测配合排查：如何定位问题" class="headerlink" title="7️⃣ 压测配合排查：如何定位问题"></a>7️⃣ 压测配合排查：如何定位问题</h2><h3 id="7-1-压测的目的"><a href="#7-1-压测的目的" class="headerlink" title="7.1 压测的目的"></a>7.1 压测的目的</h3><p><strong>压测的作用</strong>：</p>
<ol>
<li><strong>验证系统容量</strong>：系统能承受多少并发</li>
<li><strong>发现性能瓶颈</strong>：定位性能问题</li>
<li><strong>验证优化效果</strong>：优化后再次压测验证</li>
</ol>
<h3 id="7-2-压测的步骤"><a href="#7-2-压测的步骤" class="headerlink" title="7.2 压测的步骤"></a>7.2 压测的步骤</h3><h4 id="步骤-1：建立基线"><a href="#步骤-1：建立基线" class="headerlink" title="步骤 1：建立基线"></a>步骤 1：建立基线</h4><p><strong>目的</strong>：了解系统正常情况下的性能指标</p>
<p><strong>需要记录的数据</strong>：</p>
<ul>
<li>CPU 使用率</li>
<li>内存使用率</li>
<li>响应时间</li>
<li>错误率</li>
<li>QPS&#x2F;TPS</li>
</ul>
<p><strong>工具</strong>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 监控系统资源</span></span><br><span class="line">top</span><br><span class="line">htop</span><br><span class="line">iostat -x 1</span><br><span class="line">vmstat 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监控应用指标</span></span><br><span class="line"><span class="comment"># 使用 APM 工具（如 Prometheus、Grafana）</span></span><br></pre></td></tr></table></figure>

<h4 id="步骤-2：逐步加压"><a href="#步骤-2：逐步加压" class="headerlink" title="步骤 2：逐步加压"></a>步骤 2：逐步加压</h4><p><strong>目的</strong>：找到系统的临界点</p>
<p><strong>方法</strong>：</p>
<ol>
<li>从低并发开始（如 10 并发）</li>
<li>逐步增加（10 → 50 → 100 → 200）</li>
<li>每个阶段稳定运行一段时间（如 5 分钟）</li>
<li>观察指标变化</li>
</ol>
<p><strong>观察指标</strong>：</p>
<ul>
<li><strong>响应时间</strong>：是否开始变慢</li>
<li><strong>错误率</strong>：是否开始出现错误</li>
<li><strong>资源使用</strong>：CPU、内存是否接近上限</li>
<li><strong>吞吐量</strong>：QPS 是否不再增长</li>
</ul>
<h4 id="步骤-3：稳定压力测试"><a href="#步骤-3：稳定压力测试" class="headerlink" title="步骤 3：稳定压力测试"></a>步骤 3：稳定压力测试</h4><p><strong>目的</strong>：验证系统在稳定压力下的表现</p>
<p><strong>方法</strong>：</p>
<ol>
<li>保持稳定的并发数（略低于临界点）</li>
<li>持续运行较长时间（如 30 分钟）</li>
<li>观察是否有内存泄漏、连接泄漏等问题</li>
</ol>
<p><strong>观察指标</strong>：</p>
<ul>
<li><strong>内存趋势</strong>：是否持续增长（内存泄漏）</li>
<li><strong>连接数</strong>：是否持续增长（连接泄漏）</li>
<li><strong>错误率</strong>：是否稳定</li>
</ul>
<h4 id="步骤-4：峰值压力测试"><a href="#步骤-4：峰值压力测试" class="headerlink" title="步骤 4：峰值压力测试"></a>步骤 4：峰值压力测试</h4><p><strong>目的</strong>：测试系统在峰值压力下的表现</p>
<p><strong>方法</strong>：</p>
<ol>
<li>快速增加到峰值并发</li>
<li>观察系统如何应对</li>
<li>观察恢复能力</li>
</ol>
<h3 id="7-3-压测配合排查-OOM"><a href="#7-3-压测配合排查-OOM" class="headerlink" title="7.3 压测配合排查 OOM"></a>7.3 压测配合排查 OOM</h3><p><strong>场景</strong>：运维反馈 OOM，需要压测配合排查</p>
<p><strong>排查步骤</strong>：</p>
<p><strong>1. 基线测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录正常情况下的内存使用</span></span><br><span class="line">free -h</span><br><span class="line">ps aux --<span class="built_in">sort</span>=-%mem | <span class="built_in">head</span> -10</span><br></pre></td></tr></table></figure>

<p><strong>2. 逐步加压</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 JMeter 或 Locust 逐步增加并发</span></span><br><span class="line"><span class="comment"># 同时监控内存使用</span></span><br><span class="line">watch -n 1 <span class="string">&#x27;free -h&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 观察内存趋势</strong></p>
<ul>
<li><strong>正常</strong>：内存使用稳定，压测停止后回落</li>
<li><strong>内存泄漏</strong>：内存持续增长，压测停止后不回落</li>
</ul>
<p><strong>4. 定位泄漏点</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Java 应用</span></span><br><span class="line">jmap -histo &lt;pid&gt; | <span class="built_in">head</span> -20  <span class="comment"># 查看对象数量</span></span><br><span class="line">jmap -dump:format=b,file=heap.hprof &lt;pid&gt;  <span class="comment"># 生成堆转储</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 应用</span></span><br><span class="line">py-spy record -o profile.svg --pid &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p><strong>5. 分析结果</strong></p>
<ul>
<li>查看哪些对象占用内存最多</li>
<li>查看对象是否应该被释放</li>
<li>定位代码中的问题</li>
</ul>
<h3 id="7-4-压测配合排查-CPU-高"><a href="#7-4-压测配合排查-CPU-高" class="headerlink" title="7.4 压测配合排查 CPU 高"></a>7.4 压测配合排查 CPU 高</h3><p><strong>场景</strong>：运维反馈 CPU 高，需要压测配合排查</p>
<p><strong>排查步骤</strong>：</p>
<p><strong>1. 基线测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录正常情况下的 CPU 使用</span></span><br><span class="line">top</span><br></pre></td></tr></table></figure>

<p><strong>2. 逐步加压</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用压测工具逐步增加并发</span></span><br><span class="line"><span class="comment"># 同时监控 CPU 使用</span></span><br><span class="line">top -H -p &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p><strong>3. 定位 CPU 占用高的线程</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看线程 CPU 占用</span></span><br><span class="line">top -H -p &lt;pid&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Java 应用：查看线程栈</span></span><br><span class="line">jstack &lt;pid&gt; | grep -A 10 <span class="string">&quot;cpu&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 应用：使用 py-spy</span></span><br><span class="line">py-spy top --pid &lt;pid&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4. 分析代码</strong></p>
<ul>
<li>查看线程栈，定位热点代码</li>
<li>分析是否有死循环、无限递归</li>
<li>分析是否有大量计算</li>
</ul>
<p><strong>5. 优化验证</strong></p>
<ul>
<li>优化代码后再次压测</li>
<li>验证 CPU 使用率是否下降</li>
</ul>
<h3 id="7-5-压测工具选择"><a href="#7-5-压测工具选择" class="headerlink" title="7.5 压测工具选择"></a>7.5 压测工具选择</h3><p><strong>JMeter</strong>：</p>
<ul>
<li><strong>优点</strong>：功能强大，支持多种协议</li>
<li><strong>缺点</strong>：资源消耗大，学习曲线陡</li>
<li><strong>适用场景</strong>：HTTP API 压测</li>
</ul>
<p><strong>Locust</strong>：</p>
<ul>
<li><strong>优点</strong>：Python 编写，易于扩展</li>
<li><strong>缺点</strong>：功能相对简单</li>
<li><strong>适用场景</strong>：HTTP API 压测，需要自定义逻辑</li>
</ul>
<p><strong>wrk</strong>：</p>
<ul>
<li><strong>优点</strong>：性能好，资源消耗低</li>
<li><strong>缺点</strong>：功能简单，需要写 Lua 脚本</li>
<li><strong>适用场景</strong>：简单 HTTP 压测</li>
</ul>
<p><strong>Apache Bench (ab)</strong>：</p>
<ul>
<li><strong>优点</strong>：简单易用</li>
<li><strong>缺点</strong>：功能有限</li>
<li><strong>适用场景</strong>：快速验证</li>
</ul>
<hr>
<h2 id="8️⃣-常见性能问题模式与解决方案"><a href="#8️⃣-常见性能问题模式与解决方案" class="headerlink" title="8️⃣ 常见性能问题模式与解决方案"></a>8️⃣ 常见性能问题模式与解决方案</h2><h3 id="8-1-问题模式-1：内存泄漏"><a href="#8-1-问题模式-1：内存泄漏" class="headerlink" title="8.1 问题模式 1：内存泄漏"></a>8.1 问题模式 1：内存泄漏</h3><p><strong>症状</strong>：</p>
<ul>
<li>内存使用持续增长</li>
<li>压测停止后内存不回落</li>
<li>最终导致 OOM</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>全局变量不断增长</li>
<li>缓存未设置上限</li>
<li>连接未关闭</li>
<li>监听器未移除</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用有界集合</li>
<li>设置缓存过期时间</li>
<li>使用连接池</li>
<li>及时移除监听器</li>
</ul>
<h3 id="8-2-问题模式-2：CPU-高"><a href="#8-2-问题模式-2：CPU-高" class="headerlink" title="8.2 问题模式 2：CPU 高"></a>8.2 问题模式 2：CPU 高</h3><p><strong>症状</strong>：</p>
<ul>
<li>CPU 使用率接近 100%</li>
<li>响应时间变慢</li>
<li>系统卡顿</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>死循环或无限递归</li>
<li>大量计算密集型任务</li>
<li>线程过多</li>
<li>锁竞争激烈</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>修复死循环</li>
<li>异步处理计算任务</li>
<li>优化线程数</li>
<li>减少锁竞争</li>
</ul>
<h3 id="8-3-问题模式-3：连接泄漏"><a href="#8-3-问题模式-3：连接泄漏" class="headerlink" title="8.3 问题模式 3：连接泄漏"></a>8.3 问题模式 3：连接泄漏</h3><p><strong>症状</strong>：</p>
<ul>
<li>数据库连接数持续增长</li>
<li>HTTP 连接数持续增长</li>
<li>最终导致连接耗尽</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>连接未关闭</li>
<li>异常未处理，连接未释放</li>
<li>连接池配置不当</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>使用 try-finally 确保连接关闭</li>
<li>使用上下文管理器</li>
<li>配置连接池最大连接数</li>
<li>设置连接超时时间</li>
</ul>
<h3 id="8-4-问题模式-4：慢查询"><a href="#8-4-问题模式-4：慢查询" class="headerlink" title="8.4 问题模式 4：慢查询"></a>8.4 问题模式 4：慢查询</h3><p><strong>症状</strong>：</p>
<ul>
<li>数据库查询慢</li>
<li>IO 等待时间长</li>
<li>响应时间变慢</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>缺少索引</li>
<li>查询语句不当</li>
<li>数据量过大</li>
<li>锁等待</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>添加索引</li>
<li>优化查询语句</li>
<li>分页查询</li>
<li>使用缓存</li>
</ul>
<h3 id="8-5-问题模式-5：线程池耗尽"><a href="#8-5-问题模式-5：线程池耗尽" class="headerlink" title="8.5 问题模式 5：线程池耗尽"></a>8.5 问题模式 5：线程池耗尽</h3><p><strong>症状</strong>：</p>
<ul>
<li>请求排队等待</li>
<li>响应时间变慢</li>
<li>线程数达到上限</li>
</ul>
<p><strong>常见原因</strong>：</p>
<ul>
<li>线程池大小配置不当</li>
<li>任务执行时间过长</li>
<li>线程阻塞</li>
</ul>
<p><strong>解决方案</strong>：</p>
<ul>
<li>调整线程池大小</li>
<li>优化任务执行时间</li>
<li>使用异步处理</li>
<li>设置任务超时</li>
</ul>
<hr>
<h2 id="9️⃣-性能优化最佳实践"><a href="#9️⃣-性能优化最佳实践" class="headerlink" title="9️⃣ 性能优化最佳实践"></a>9️⃣ 性能优化最佳实践</h2><h3 id="9-1-代码层面"><a href="#9-1-代码层面" class="headerlink" title="9.1 代码层面"></a>9.1 代码层面</h3><h4 id="实践-1：避免内存泄漏"><a href="#实践-1：避免内存泄漏" class="headerlink" title="实践 1：避免内存泄漏"></a>实践 1：避免内存泄漏</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ✅ 使用上下文管理器</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 使用连接池</span></span><br><span class="line"><span class="keyword">with</span> get_connection() <span class="keyword">as</span> conn:</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    cursor.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 使用有界缓存</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(<span class="params">maxsize=<span class="number">1000</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">expensive_function</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">return</span> compute(x)</span><br></pre></td></tr></table></figure>

<h4 id="实践-2：优化-IO-操作"><a href="#实践-2：优化-IO-操作" class="headerlink" title="实践 2：优化 IO 操作"></a>实践 2：优化 IO 操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ✅ 批量操作</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">batch_insert</span>(<span class="params">records</span>):</span><br><span class="line">    <span class="keyword">with</span> get_connection() <span class="keyword">as</span> conn:</span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        cursor.executemany(<span class="string">&quot;INSERT INTO users VALUES (?, ?)&quot;</span>, records)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 使用连接池</span></span><br><span class="line">pool = ConnectionPool(max_connections=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 异步 IO</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">fetch_data</span>(<span class="params">url</span>):</span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line">        <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">await</span> response.json()</span><br></pre></td></tr></table></figure>

<h4 id="实践-3：减少锁竞争"><a href="#实践-3：减少锁竞争" class="headerlink" title="实践 3：减少锁竞争"></a>实践 3：减少锁竞争</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ✅ 减少锁的粒度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">process_data</span>(<span class="params">data</span>):</span><br><span class="line">    <span class="comment"># 不需要锁的操作</span></span><br><span class="line">    processed = preprocess(data)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 只在必要时加锁</span></span><br><span class="line">    <span class="keyword">with</span> lock:</span><br><span class="line">        shared_resource.update(processed)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 不需要锁的操作</span></span><br><span class="line">    <span class="keyword">return</span> postprocess(processed)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ✅ 使用无锁数据结构</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">queue = deque()  <span class="comment"># 线程安全的操作</span></span><br></pre></td></tr></table></figure>

<h3 id="9-2-架构层面"><a href="#9-2-架构层面" class="headerlink" title="9.2 架构层面"></a>9.2 架构层面</h3><h4 id="实践-1：使用缓存"><a href="#实践-1：使用缓存" class="headerlink" title="实践 1：使用缓存"></a>实践 1：使用缓存</h4><p><strong>缓存策略</strong>：</p>
<ul>
<li><strong>本地缓存</strong>：快速但容量有限</li>
<li><strong>分布式缓存</strong>：容量大但需要网络</li>
<li><strong>多级缓存</strong>：结合两者优势</li>
</ul>
<p><strong>缓存更新策略</strong>：</p>
<ul>
<li><strong>Cache-Aside</strong>：应用负责缓存更新</li>
<li><strong>Write-Through</strong>：写入时同时更新缓存</li>
<li><strong>Write-Behind</strong>：异步更新缓存</li>
</ul>
<h4 id="实践-2：使用队列削峰"><a href="#实践-2：使用队列削峰" class="headerlink" title="实践 2：使用队列削峰"></a>实践 2：使用队列削峰</h4><p><strong>场景</strong>：高峰期请求量大</p>
<p><strong>方案</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求 → 队列 → 后台处理</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>：</p>
<ul>
<li>削峰填谷</li>
<li>系统更稳定</li>
<li>用户体验更好</li>
</ul>
<h4 id="实践-3：异步处理"><a href="#实践-3：异步处理" class="headerlink" title="实践 3：异步处理"></a>实践 3：异步处理</h4><p><strong>场景</strong>：不需要立即返回结果的操作</p>
<p><strong>方案</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户请求 → 立即返回 → 任务入队 → 后台处理</span><br></pre></td></tr></table></figure>

<p><strong>优势</strong>：</p>
<ul>
<li>响应更快</li>
<li>系统吞吐量更高</li>
<li>资源利用率更高</li>
</ul>
<h3 id="9-3-监控与告警"><a href="#9-3-监控与告警" class="headerlink" title="9.3 监控与告警"></a>9.3 监控与告警</h3><h4 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h4><p><strong>系统指标</strong>：</p>
<ul>
<li>CPU 使用率</li>
<li>内存使用率</li>
<li>磁盘 IO</li>
<li>网络 IO</li>
</ul>
<p><strong>应用指标</strong>：</p>
<ul>
<li>响应时间</li>
<li>错误率</li>
<li>QPS&#x2F;TPS</li>
<li>连接数</li>
</ul>
<p><strong>业务指标</strong>：</p>
<ul>
<li>订单量</li>
<li>用户数</li>
<li>交易量</li>
</ul>
<h4 id="告警规则"><a href="#告警规则" class="headerlink" title="告警规则"></a>告警规则</h4><p><strong>告警条件</strong>：</p>
<ul>
<li>CPU 使用率 &gt; 80% 持续 5 分钟</li>
<li>内存使用率 &gt; 90%</li>
<li>错误率 &gt; 1%</li>
<li>响应时间 &gt; 1 秒</li>
</ul>
<p><strong>告警处理</strong>：</p>
<ul>
<li>自动扩容</li>
<li>降级处理</li>
<li>通知相关人员</li>
</ul>
<h3 id="9-4-压测实践"><a href="#9-4-压测实践" class="headerlink" title="9.4 压测实践"></a>9.4 压测实践</h3><h4 id="压测前准备"><a href="#压测前准备" class="headerlink" title="压测前准备"></a>压测前准备</h4><ol>
<li><strong>环境准备</strong>：独立的压测环境</li>
<li><strong>数据准备</strong>：足够的测试数据</li>
<li><strong>监控准备</strong>：监控系统就绪</li>
<li><strong>预案准备</strong>：应急预案准备</li>
</ol>
<h4 id="压测执行"><a href="#压测执行" class="headerlink" title="压测执行"></a>压测执行</h4><ol>
<li><strong>逐步加压</strong>：从低到高逐步增加</li>
<li><strong>稳定测试</strong>：每个阶段稳定运行</li>
<li><strong>记录数据</strong>：详细记录各项指标</li>
<li><strong>分析问题</strong>：及时分析发现的问题</li>
</ol>
<h4 id="压测后分析"><a href="#压测后分析" class="headerlink" title="压测后分析"></a>压测后分析</h4><ol>
<li><strong>数据分析</strong>：分析各项指标</li>
<li><strong>问题定位</strong>：定位性能瓶颈</li>
<li><strong>优化方案</strong>：制定优化方案</li>
<li><strong>验证效果</strong>：优化后再次压测验证</li>
</ol>
<hr>
<h2 id="📝-总结"><a href="#📝-总结" class="headerlink" title="📝 总结"></a>📝 总结</h2><h3 id="核心要点"><a href="#核心要点" class="headerlink" title="核心要点"></a>核心要点</h3><ol>
<li><strong>资源本质</strong>：CPU、内存、IO 是服务器的三大核心资源</li>
<li><strong>问题根源</strong>：资源竞争和瓶颈导致性能问题</li>
<li><strong>常见问题</strong>：OOM、CPU 高、连接泄漏、慢查询</li>
<li><strong>解决方案</strong>：异步处理、队列、缓存、连接池</li>
<li><strong>排查方法</strong>：监控、压测、分析工具</li>
</ol>
<h3 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h3><p><strong>遇到性能问题时</strong>：</p>
<ol>
<li><strong>观察现象</strong>：CPU 高？内存高？响应慢？</li>
<li><strong>定位资源</strong>：哪个资源是瓶颈？</li>
<li><strong>分析原因</strong>：为什么会出现这个问题？</li>
<li><strong>制定方案</strong>：如何解决？</li>
<li><strong>验证效果</strong>：优化后是否改善？</li>
</ol>
<h3 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h3><ol>
<li><strong>预防为主</strong>：代码层面避免常见问题</li>
<li><strong>监控告警</strong>：及时发现问题</li>
<li><strong>压测验证</strong>：定期压测验证系统性能</li>
<li><strong>持续优化</strong>：根据监控和压测结果持续优化</li>
</ol>
<hr>
<h2 id="📚-延伸阅读"><a href="#📚-延伸阅读" class="headerlink" title="📚 延伸阅读"></a>📚 延伸阅读</h2><h3 id="工具推荐"><a href="#工具推荐" class="headerlink" title="工具推荐"></a>工具推荐</h3><p><strong>监控工具</strong>：</p>
<ul>
<li><strong>Prometheus + Grafana</strong>：系统监控</li>
<li><strong>APM 工具</strong>：应用性能监控（如 New Relic、Datadog）</li>
<li><strong>日志分析</strong>：ELK Stack（Elasticsearch、Logstash、Kibana）</li>
</ul>
<p><strong>压测工具</strong>：</p>
<ul>
<li><strong>JMeter</strong>：功能强大的压测工具</li>
<li><strong>Locust</strong>：Python 编写的压测工具</li>
<li><strong>wrk</strong>：高性能 HTTP 压测工具</li>
</ul>
<p><strong>分析工具</strong>：</p>
<ul>
<li><strong>Java</strong>：jstack、jmap、VisualVM</li>
<li><strong>Python</strong>：py-spy、memory_profiler</li>
<li><strong>系统</strong>：top、htop、iostat、vmstat</li>
</ul>
<h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><ul>
<li><a href="/2025/06/30/2025-06-30-streaming-api-performance-test/">流式接口压测实践</a></li>
<li><a href="/2025/06/30/2025-06-30-mysql-connection-leak-fix/">数据库连接泄漏排查</a></li>
<li><a href="/2025/08/06/2025-08-06-qps-vs-rps/">QPS vs RPS 的区别</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://linn0813.github.io">yuxiaoling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://linn0813.github.io/2026/01/06/2026-01-06-server-performance-troubleshooting-guide/">https://linn0813.github.io/2026/01/06/2026-01-06-server-performance-troubleshooting-guide/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">版权所有，转载请注明出处。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8E%8B%E6%B5%8B/">压测</a><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%80%A7%E8%83%BD/">服务器性能</a><a class="post-meta__tags" href="/tags/OOM/">OOM</a><a class="post-meta__tags" href="/tags/CPU/">CPU</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/">异步处理</a><a class="post-meta__tags" href="/tags/%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86/">资源管理</a></div><div class="post-share"><div class="social-share" data-image="/img/server-performance-guide.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2026/01/05/2026-01-05-llm-agent-future-summary/" title="🌐 主题19｜Agent 工程未来：趋势、机会与系列总结"><img class="cover" src="/img/llm-agent-future-summary.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">🌐 主题19｜Agent 工程未来：趋势、机会与系列总结</div></div><div class="info-2"><div class="info-item-1"> 这是《🧠 LLM&#x2F;Agent 从入门到精通：告别浅尝辄止》系列第 19 篇（收官篇）   上一篇我们深入 Agent 的伦理边界，探讨了偏见、问责制与负责任的 AI。   本篇，我们将对整个系列进行工程总结，并展望未来五年 Agent 技术的发展趋势、落地机遇以及企业应用潜力。   🚀 导言 — 从”实验室”到”企业主流”经过前 18 篇对 Agent 的构建、治理、调优、应用和伦理边界的系统解析，我们已经掌握了构建高效、可靠和安全 Agent 的全流程。 本篇将对整个系列内容进行工程总结，并展望未来五年 Agent 技术的发展趋势、落地机遇以及企业应用潜力。  一、 Agent 工程的全景总结1.1 核心技术闭环Agent 构建和优化涉及四大核心环节：    环节 核心内容 关键实践    能力评估 准确性、鲁棒性、成本效益 采用 Judge LLM、Failure Mode Analysis、自动化指标收集   能力调优 Prompt Engineering、高效微调（LoRA&#x2F;PEFT） Structured CoT、拒绝机制、工具 Schema...</div></div></div></a><a class="pagination-related" href="/2026/01/07/2026-01-07-performance-monitoring-dashboard-guide/" title="📊 压测时，我是如何一步步「读懂」性能监控面板的"><img class="cover" src="/img/performance-monitoring-dashboard-guide.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">📊 压测时，我是如何一步步「读懂」性能监控面板的</div></div><div class="info-2"><div class="info-item-1">压测时，我是如何一步步「读懂」性能监控面板的 📊 从”看不懂 CES &#x2F; CPU &#x2F; Memory 面板”，到”能用它们做结论判断”  这是我第一次在压测过程中，真正独立去看服务器性能面板。运维给了我一个临时的监控链接，里面有 CES、CPU Utilization、Memory Utilization 等指标。 当时我的真实感受是：  每一个指标我都”认识”，但连在一起就完全不知道在说什么。  这篇文章不是讲「CPU 是什么、内存是什么」而是想聊清楚一件事👇  压测时，我们到底应该”怎么看面板”，以及”从面板中得出什么结论”。   一、先说结论：压测看面板，不是看”数值”，而是看”关系” 🧠很多新手（包括我自己一开始）都会犯一个错误：  ❌ CPU 高不高？❌ 内存满不满？  但真实的压测判断是：  ✅ 在当前压测强度下，这些指标是否”符合预期关系”  性能问题，本质上是...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/06/2025-08-06-qps-vs-rps/" title="别再用 QPS 计算并发数了！我曾经也犯了这个错误"><img class="cover" src="/img/qps-rps.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-06</div><div class="info-item-2">别再用 QPS 计算并发数了！我曾经也犯了这个错误</div></div><div class="info-2"><div class="info-item-1">别再用 QPS 计算并发数了！我曾经也犯了这个错误✍️ 前言：一次“压测误区”的反思在一次压测计划中，我想要模拟系统在 QPS 为 500 的情况下运行一分钟，于是直接算了下：  500 QPS × 60 秒 &#x3D; 30,000 请求  我很自然地把这个数当成“发起请求的总数”，在压测工具里配置成了对应的并发请求和速率。可实际执行后，结果完全不对劲：服务器很快就吃不消，响应成功数远低于预期，日志也开始大量报错。 后来我才意识到，原来我混淆了 QPS 的含义。压测工具配置的是发起请求数（RPS），而我想要的是成功处理数（QPS）。这之间的误解，足以让一次压测结果严重失真。  📌 QPS、RPS、TPS 到底有啥区别？   概念 全称 关注点 说明    QPS Queries Per Second 服务端处理能力 每秒成功响应的请求数   RPS Requests Per Second 客户端施压能力 每秒发起的请求数，不一定全部处理成功   TPS Transactions Per Second 事务处理能力 每秒完成的事务数量（如数据库事务）    🎯...</div></div></div></a><a class="pagination-related" href="/2026/01/07/2026-01-07-performance-monitoring-dashboard-guide/" title="📊 压测时，我是如何一步步「读懂」性能监控面板的"><img class="cover" src="/img/performance-monitoring-dashboard-guide.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-07</div><div class="info-item-2">📊 压测时，我是如何一步步「读懂」性能监控面板的</div></div><div class="info-2"><div class="info-item-1">压测时，我是如何一步步「读懂」性能监控面板的 📊 从”看不懂 CES &#x2F; CPU &#x2F; Memory 面板”，到”能用它们做结论判断”  这是我第一次在压测过程中，真正独立去看服务器性能面板。运维给了我一个临时的监控链接，里面有 CES、CPU Utilization、Memory Utilization 等指标。 当时我的真实感受是：  每一个指标我都”认识”，但连在一起就完全不知道在说什么。  这篇文章不是讲「CPU 是什么、内存是什么」而是想聊清楚一件事👇  压测时，我们到底应该”怎么看面板”，以及”从面板中得出什么结论”。   一、先说结论：压测看面板，不是看”数值”，而是看”关系” 🧠很多新手（包括我自己一开始）都会犯一个错误：  ❌ CPU 高不高？❌ 内存满不满？  但真实的压测判断是：  ✅ 在当前压测强度下，这些指标是否”符合预期关系”  性能问题，本质上是...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/ loading='lazy'></div><div class="author-info-name">yuxiaoling</div><div class="author-info-description">分享软件测试学习、实战经验和踩坑历程</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">389</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Linn0813"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Linn0813" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yuxiaoling.yxl@qq.com" target="_blank" title="Email"><i class="fa fa-envelope-open-text"></i></a><a class="social-icon" href="javascript:alert('微信公众号：Linn的技术笔记')" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://weibo.com/Linn0813" target="_blank" title="微博"><i class="fab fa-weibo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">下雨就不想上班 / 出太阳也不想上班</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8B-%E7%9B%AE%E5%BD%95%E6%A6%82%E8%A7%88"><span class="toc-number">1.</span> <span class="toc-text">📋 目录概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E7%90%86%E8%A7%A3%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B5%84%E6%BA%90%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.</span> <span class="toc-text">1️⃣ 理解服务器资源的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%89%E5%A4%A7%E8%B5%84%E6%BA%90%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 三大资源的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E8%B5%84%E6%BA%90%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 资源之间的关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%9A%E8%B5%84%E6%BA%90%E7%AB%9E%E4%BA%89%E4%B8%8E%E7%93%B6%E9%A2%88"><span class="toc-number">3.</span> <span class="toc-text">2️⃣ 性能问题的根源：资源竞争与瓶颈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 什么是性能问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E8%B5%84%E6%BA%90%E7%93%B6%E9%A2%88%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 资源瓶颈的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-CPU-%E7%93%B6%E9%A2%88"><span class="toc-number">3.2.1.</span> <span class="toc-text">2.2.1 CPU 瓶颈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-%E5%86%85%E5%AD%98%E7%93%B6%E9%A2%88"><span class="toc-number">3.2.2.</span> <span class="toc-text">2.2.2 内存瓶颈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-IO-%E7%93%B6%E9%A2%88"><span class="toc-number">3.2.3.</span> <span class="toc-text">2.2.3 IO 瓶颈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E8%B5%84%E6%BA%90%E7%93%B6%E9%A2%88%E7%9A%84%E8%BF%9E%E9%94%81%E5%8F%8D%E5%BA%94"><span class="toc-number">3.3.</span> <span class="toc-text">2.3 资源瓶颈的连锁反应</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E5%86%85%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%9AOOM-%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">3️⃣ 内存问题：OOM 与内存泄漏</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E4%BB%80%E4%B9%88%E6%98%AF-OOM%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 什么是 OOM？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-OOM-%E7%9A%84%E5%B8%B8%E8%A7%81%E5%9C%BA%E6%99%AF"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 OOM 的常见场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">场景 1：内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-2%EF%BC%9A%E5%A4%A7%E5%AF%B9%E8%B1%A1%E9%A2%91%E7%B9%81%E5%88%9B%E5%BB%BA"><span class="toc-number">4.2.2.</span> <span class="toc-text">场景 2：大对象频繁创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%9C%AA%E9%87%8A%E6%94%BE"><span class="toc-number">4.2.3.</span> <span class="toc-text">场景 3：连接池未释放</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">3.3 内存泄漏的排查方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1%EF%BC%9A%E7%9B%91%E6%8E%A7%E5%86%85%E5%AD%98%E8%B6%8B%E5%8A%BF"><span class="toc-number">4.3.1.</span> <span class="toc-text">方法 1：监控内存趋势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7"><span class="toc-number">4.3.2.</span> <span class="toc-text">方法 2：使用内存分析工具</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3%EF%BC%9A%E5%8E%8B%E6%B5%8B%E9%85%8D%E5%90%88%E6%8E%92%E6%9F%A5"><span class="toc-number">4.3.3.</span> <span class="toc-text">方法 3：压测配合排查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-CPU-%E9%97%AE%E9%A2%98%EF%BC%9A%E9%AB%98%E8%B4%9F%E8%BD%BD%E4%B8%8E%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.</span> <span class="toc-text">4️⃣ CPU 问题：高负载与死循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-CPU-%E9%AB%98%E8%B4%9F%E8%BD%BD%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 CPU 高负载的原因</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-1%EF%BC%9A%E6%AD%BB%E5%BE%AA%E7%8E%AF%E6%88%96%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92"><span class="toc-number">5.1.1.</span> <span class="toc-text">原因 1：死循环或无限递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-2%EF%BC%9A%E5%A4%A7%E9%87%8F%E8%AE%A1%E7%AE%97%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.1.2.</span> <span class="toc-text">原因 2：大量计算密集型任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E5%9B%A0-3%EF%BC%9A%E7%BA%BF%E7%A8%8B%E8%BF%87%E5%A4%9A"><span class="toc-number">5.1.3.</span> <span class="toc-text">原因 3：线程过多</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-CPU-%E9%97%AE%E9%A2%98%E7%9A%84%E6%8E%92%E6%9F%A5%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 CPU 问题的排查方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1%EF%BC%9A%E5%AE%9A%E4%BD%8D-CPU-%E5%8D%A0%E7%94%A8%E6%9C%80%E9%AB%98%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">方法 1：定位 CPU 占用最高的线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2%EF%BC%9A%E5%88%86%E6%9E%90%E7%BA%BF%E7%A8%8B%E6%A0%88"><span class="toc-number">5.2.2.</span> <span class="toc-text">方法 2：分析线程栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3%EF%BC%9A%E5%8E%8B%E6%B5%8B%E9%85%8D%E5%90%88%E6%8E%92%E6%9F%A5-1"><span class="toc-number">5.2.3.</span> <span class="toc-text">方法 3：压测配合排查</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%EF%B8%8F%E2%83%A3-%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%BC%82%E6%AD%A5%E3%80%81%E9%98%9F%E5%88%97%E4%B8%8E%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">5️⃣ 并发处理机制：异步、队列与锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 为什么需要并发处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%EF%BC%88Async%EF%BC%89"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 异步处理（Async）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E6%AD%A5%EF%BC%9F"><span class="toc-number">6.2.1.</span> <span class="toc-text">5.2.1 什么是异步？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-%E5%BC%82%E6%AD%A5%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">6.2.2.</span> <span class="toc-text">5.2.2 异步的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-%E5%BC%82%E6%AD%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">6.2.3.</span> <span class="toc-text">5.2.3 异步的实现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="toc-number">6.3.</span> <span class="toc-text">5.3 队列（Queue）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%9F%E5%88%97%EF%BC%9F"><span class="toc-number">6.3.1.</span> <span class="toc-text">5.3.1 什么是队列？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E9%98%9F%E5%88%97%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.3.2.</span> <span class="toc-text">5.3.2 队列的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.3.</span> <span class="toc-text">5.3.3 队列的使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E9%94%81%EF%BC%88Lock%EF%BC%89"><span class="toc-number">6.4.</span> <span class="toc-text">5.4 锁（Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%94%81%EF%BC%9F"><span class="toc-number">6.4.1.</span> <span class="toc-text">5.4.1 为什么需要锁？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.4.2.</span> <span class="toc-text">5.4.2 锁的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E9%94%81%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="toc-number">6.4.3.</span> <span class="toc-text">5.4.3 锁的常见问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%EF%B8%8F%E2%83%A3-IO-%E9%98%BB%E5%A1%9E%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AD%89%E5%BE%85"><span class="toc-number">7.</span> <span class="toc-text">6️⃣ IO 阻塞与资源等待</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-IO-%E9%98%BB%E5%A1%9E%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 IO 阻塞的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-IO-%E9%98%BB%E5%A1%9E%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 IO 阻塞的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-1%EF%BC%9A%E5%BC%82%E6%AD%A5-IO"><span class="toc-number">7.2.1.</span> <span class="toc-text">方案 1：异步 IO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-2%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="toc-number">7.2.2.</span> <span class="toc-text">方案 2：连接池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-3%EF%BC%9A%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86"><span class="toc-number">7.2.3.</span> <span class="toc-text">方案 3：批量处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E8%B5%84%E6%BA%90%E7%AD%89%E5%BE%85%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 资源等待的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-1%EF%BC%9A%E8%B6%85%E6%97%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.1.</span> <span class="toc-text">优化 1：超时机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-2%EF%BC%9A%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.2.</span> <span class="toc-text">优化 2：重试机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96-3%EF%BC%9A%E7%BC%93%E5%AD%98"><span class="toc-number">7.3.3.</span> <span class="toc-text">优化 3：缓存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%EF%B8%8F%E2%83%A3-%E5%8E%8B%E6%B5%8B%E9%85%8D%E5%90%88%E6%8E%92%E6%9F%A5%EF%BC%9A%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">7️⃣ 压测配合排查：如何定位问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%8E%8B%E6%B5%8B%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 压测的目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E5%8E%8B%E6%B5%8B%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 压测的步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E5%BB%BA%E7%AB%8B%E5%9F%BA%E7%BA%BF"><span class="toc-number">8.2.1.</span> <span class="toc-text">步骤 1：建立基线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E9%80%90%E6%AD%A5%E5%8A%A0%E5%8E%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">步骤 2：逐步加压</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E7%A8%B3%E5%AE%9A%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">8.2.3.</span> <span class="toc-text">步骤 3：稳定压力测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-4%EF%BC%9A%E5%B3%B0%E5%80%BC%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95"><span class="toc-number">8.2.4.</span> <span class="toc-text">步骤 4：峰值压力测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8E%8B%E6%B5%8B%E9%85%8D%E5%90%88%E6%8E%92%E6%9F%A5-OOM"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 压测配合排查 OOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E5%8E%8B%E6%B5%8B%E9%85%8D%E5%90%88%E6%8E%92%E6%9F%A5-CPU-%E9%AB%98"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 压测配合排查 CPU 高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7%E9%80%89%E6%8B%A9"><span class="toc-number">8.5.</span> <span class="toc-text">7.5 压测工具选择</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%B8%8F%E2%83%A3-%E5%B8%B8%E8%A7%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%A8%A1%E5%BC%8F%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">9.</span> <span class="toc-text">8️⃣ 常见性能问题模式与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E9%97%AE%E9%A2%98%E6%A8%A1%E5%BC%8F-1%EF%BC%9A%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">9.1.</span> <span class="toc-text">8.1 问题模式 1：内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E9%97%AE%E9%A2%98%E6%A8%A1%E5%BC%8F-2%EF%BC%9ACPU-%E9%AB%98"><span class="toc-number">9.2.</span> <span class="toc-text">8.2 问题模式 2：CPU 高</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E9%97%AE%E9%A2%98%E6%A8%A1%E5%BC%8F-3%EF%BC%9A%E8%BF%9E%E6%8E%A5%E6%B3%84%E6%BC%8F"><span class="toc-number">9.3.</span> <span class="toc-text">8.3 问题模式 3：连接泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E9%97%AE%E9%A2%98%E6%A8%A1%E5%BC%8F-4%EF%BC%9A%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">9.4.</span> <span class="toc-text">8.4 问题模式 4：慢查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E9%97%AE%E9%A2%98%E6%A8%A1%E5%BC%8F-5%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%80%97%E5%B0%BD"><span class="toc-number">9.5.</span> <span class="toc-text">8.5 问题模式 5：线程池耗尽</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%EF%B8%8F%E2%83%A3-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.</span> <span class="toc-text">9️⃣ 性能优化最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2"><span class="toc-number">10.1.</span> <span class="toc-text">9.1 代码层面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-1%EF%BC%9A%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">10.1.1.</span> <span class="toc-text">实践 1：避免内存泄漏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-2%EF%BC%9A%E4%BC%98%E5%8C%96-IO-%E6%93%8D%E4%BD%9C"><span class="toc-number">10.1.2.</span> <span class="toc-text">实践 2：优化 IO 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-3%EF%BC%9A%E5%87%8F%E5%B0%91%E9%94%81%E7%AB%9E%E4%BA%89"><span class="toc-number">10.1.3.</span> <span class="toc-text">实践 3：减少锁竞争</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%9E%B6%E6%9E%84%E5%B1%82%E9%9D%A2"><span class="toc-number">10.2.</span> <span class="toc-text">9.2 架构层面</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-1%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BC%93%E5%AD%98"><span class="toc-number">10.2.1.</span> <span class="toc-text">实践 1：使用缓存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97%E5%89%8A%E5%B3%B0"><span class="toc-number">10.2.2.</span> <span class="toc-text">实践 2：使用队列削峰</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5-3%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86"><span class="toc-number">10.2.3.</span> <span class="toc-text">实践 3：异步处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E7%9B%91%E6%8E%A7%E4%B8%8E%E5%91%8A%E8%AD%A6"><span class="toc-number">10.3.</span> <span class="toc-text">9.3 监控与告警</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="toc-number">10.3.1.</span> <span class="toc-text">监控指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%8A%E8%AD%A6%E8%A7%84%E5%88%99"><span class="toc-number">10.3.2.</span> <span class="toc-text">告警规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%8E%8B%E6%B5%8B%E5%AE%9E%E8%B7%B5"><span class="toc-number">10.4.</span> <span class="toc-text">9.4 压测实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E6%B5%8B%E5%89%8D%E5%87%86%E5%A4%87"><span class="toc-number">10.4.1.</span> <span class="toc-text">压测前准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E6%B5%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">10.4.2.</span> <span class="toc-text">压测执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E6%B5%8B%E5%90%8E%E5%88%86%E6%9E%90"><span class="toc-number">10.4.3.</span> <span class="toc-text">压测后分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9D-%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">📝 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9"><span class="toc-number">11.1.</span> <span class="toc-text">核心要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF"><span class="toc-number">11.2.</span> <span class="toc-text">排查思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">11.3.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%9A-%E5%BB%B6%E4%BC%B8%E9%98%85%E8%AF%BB"><span class="toc-number">12.</span> <span class="toc-text">📚 延伸阅读</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%8E%A8%E8%8D%90"><span class="toc-number">12.1.</span> <span class="toc-text">工具推荐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0"><span class="toc-number">12.2.</span> <span class="toc-text">相关文章</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/01/26/2026-01-26-localhost-wifi-access-guide/" title="同一 Wi‑Fi 访问本地服务：网络模型、配置方式与边界说明"><img src="/img/localhost-wifi-access-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="同一 Wi‑Fi 访问本地服务：网络模型、配置方式与边界说明"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/26/2026-01-26-localhost-wifi-access-guide/" title="同一 Wi‑Fi 访问本地服务：网络模型、配置方式与边界说明">同一 Wi‑Fi 访问本地服务：网络模型、配置方式与边界说明</a><time datetime="2026-01-26T02:00:00.000Z" title="发表于 2026-01-26 10:00:00">2026-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/21/2026-01-21-sitemap-search-engine-seo-guide/" title="🧭 如何把个人博客挂到搜索引擎上？"><img src="/img/sitemap-search-engine-seo-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🧭 如何把个人博客挂到搜索引擎上？"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/21/2026-01-21-sitemap-search-engine-seo-guide/" title="🧭 如何把个人博客挂到搜索引擎上？">🧭 如何把个人博客挂到搜索引擎上？</a><time datetime="2026-01-21T11:00:00.000Z" title="发表于 2026-01-21 19:00:00">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/21/2026-01-21-python-xmind-operation-guide/" title="🗺️ 用 Python 操作 XMind：从读懂到生成的完整入门指南"><img src="/img/python-xmind-operation-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🗺️ 用 Python 操作 XMind：从读懂到生成的完整入门指南"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/21/2026-01-21-python-xmind-operation-guide/" title="🗺️ 用 Python 操作 XMind：从读懂到生成的完整入门指南">🗺️ 用 Python 操作 XMind：从读懂到生成的完整入门指南</a><time datetime="2026-01-21T07:00:00.000Z" title="发表于 2026-01-21 15:00:00">2026-01-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/20/2026-01-20-frontend-file-extensions-guide/" title="📄 一篇搞懂前端常见文件后缀：ts / tsc / jsx / tsx / scss"><img src="/img/frontend-file-extensions-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="📄 一篇搞懂前端常见文件后缀：ts / tsc / jsx / tsx / scss"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/20/2026-01-20-frontend-file-extensions-guide/" title="📄 一篇搞懂前端常见文件后缀：ts / tsc / jsx / tsx / scss">📄 一篇搞懂前端常见文件后缀：ts / tsc / jsx / tsx / scss</a><time datetime="2026-01-20T08:00:00.000Z" title="发表于 2026-01-20 16:00:00">2026-01-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/20/2026-01-20-llm-integration-what-are-you-calling/" title="🤖 项目里调用大模型，其实在调用什么？"><img src="/img/llm-integration-what-are-you-calling.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🤖 项目里调用大模型，其实在调用什么？"/ loading='lazy'></a><div class="content"><a class="title" href="/2026/01/20/2026-01-20-llm-integration-what-are-you-calling/" title="🤖 项目里调用大模型，其实在调用什么？">🤖 项目里调用大模型，其实在调用什么？</a><time datetime="2026-01-20T02:00:00.000Z" title="发表于 2026-01-20 10:00:00">2026-01-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 - 2026 By yuxiaoling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'Linn0813/Linn0813.github.io',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script src="/js/blog-enhancements.js"></script><script src="/js/category-enhancements.js"></script><script src="/js/archive-enhancements.js"></script><script src="/js/tag-enhancements.js"></script><script src="/js/index-enhancements.js"></script><script src="/js/theme-switcher-ui.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章、分类、标签..." type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>