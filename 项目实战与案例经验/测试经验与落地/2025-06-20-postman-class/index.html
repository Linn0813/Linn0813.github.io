<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从入门到实战：一篇文章掌握接口测试与 Postman 全流程 | Linn's Blog</title><meta name="author" content="yuxiaoling"><meta name="copyright" content="yuxiaoling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分享码尚教育Postman课程的学习内容，详细介绍接口测试的概念、分类、流程与用例设计，全面讲解 Postman 的使用方法，包括界面操作、断言设置、数据驱动测试和 Mock Server 等功能，适合接口测试初学者与自动化测试入门者学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="从入门到实战：一篇文章掌握接口测试与 Postman 全流程">
<meta property="og:url" content="https://linn0813.github.io/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-06-20-postman-class/index.html">
<meta property="og:site_name" content="Linn&#39;s Blog">
<meta property="og:description" content="分享码尚教育Postman课程的学习内容，详细介绍接口测试的概念、分类、流程与用例设计，全面讲解 Postman 的使用方法，包括界面操作、断言设置、数据驱动测试和 Mock Server 等功能，适合接口测试初学者与自动化测试入门者学习。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://linn0813.github.io/img/postman-class.png">
<meta property="article:published_time" content="2025-06-20T02:09:35.000Z">
<meta property="article:modified_time" content="2025-11-29T15:36:02.626Z">
<meta property="article:author" content="yuxiaoling">
<meta property="article:tag" content="自动化测试">
<meta property="article:tag" content="Postman">
<meta property="article:tag" content="软件测试">
<meta property="article:tag" content="接口测试">
<meta property="article:tag" content="测试用例">
<meta property="article:tag" content="Newman">
<meta property="article:tag" content="Mock Server">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://linn0813.github.io/img/postman-class.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从入门到实战：一篇文章掌握接口测试与 Postman 全流程",
  "url": "https://linn0813.github.io/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-06-20-postman-class/",
  "image": "https://linn0813.github.io/img/postman-class.png",
  "datePublished": "2025-06-20T02:09:35.000Z",
  "dateModified": "2025-11-29T15:36:02.626Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuxiaoling",
      "url": "https://linn0813.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://linn0813.github.io/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-06-20-postman-class/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从入门到实战：一篇文章掌握接口测试与 Postman 全流程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/blog-enhancements.css"><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/ loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">314</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/series/"><i class="fa-fw fa fa-book"></i><span> 系列</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/postman-class.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/logo.jpg" alt="Logo" loading='lazy'><span class="site-name">Linn's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">从入门到实战：一篇文章掌握接口测试与 Postman 全流程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/series/"><i class="fa-fw fa fa-book"></i><span> 系列</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">从入门到实战：一篇文章掌握接口测试与 Postman 全流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-20T02:09:35.000Z" title="发表于 2025-06-20 10:09:35">2025-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-29T15:36:02.626Z" title="更新于 2025-11-29 23:36:02">2025-11-29</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/">项目实战与案例经验</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/">测试经验与落地</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;天自上次更新，文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-11-29 23:36:02&quot;}" hidden></div><blockquote>
<p>🚀 这是我在 B 站课程《接口测试的简介与分类》（<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11K4y1J7sh?vd_source=65c2968c09490f4b218154711916b4d8">点击直达</a>）学习过程中的详细笔记与实操总结，面向接口测试初学者与自动化测试入门者，希望对你有所启发。</p>
</blockquote>
<hr>
<h1 id="🌐-接口测试的简介与分类"><a href="#🌐-接口测试的简介与分类" class="headerlink" title="🌐 接口测试的简介与分类"></a>🌐 接口测试的简介与分类</h1><h2 id="❓-什么是接口测试？"><a href="#❓-什么是接口测试？" class="headerlink" title="❓ 什么是接口测试？"></a>❓ 什么是接口测试？</h2><p>接口测试是指对系统组件之间的数据传递、业务逻辑接口等内容进行测试，验证各模块间是否能正确交互与协作。🔁</p>
<h2 id="📂-接口测试分类："><a href="#📂-接口测试分类：" class="headerlink" title="📂 接口测试分类："></a>📂 接口测试分类：</h2><ul>
<li><p><strong>外部接口测试</strong><br>系统对接外部第三方服务，如支付接口、物流接口，主要验证正向功能。<br>○ 只需验证正例（接口是否返回成功）✅</p>
</li>
<li><p><strong>内部接口测试</strong><br>○ ① 内部调用接口：模块之间对接使用，如预算系统与承保系统。<br>■ 只需验证正例<br>○ ② 开放给外部的内部接口：业务核心接口，如 App 端调用后端接口。<br>■ 需验证正例 + 异常 + 权限 + 安全性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>典型场景</th>
<th>测试重点</th>
<th>扩展测试点</th>
</tr>
</thead>
<tbody><tr>
<td>外部接口</td>
<td>第三方支付、物流查询</td>
<td>正向流程（如支付下单 - 回调通知）</td>
<td>网络异常（断网、超时）、限流处理</td>
</tr>
<tr>
<td>内部接口</td>
<td>电商系统“库存扣减”与“订单创建”对接</td>
<td>数据一致性（库存扣减失败时订单回滚）</td>
<td>并发调用（多用户同时下单锁机制）</td>
</tr>
<tr>
<td>开放内部接口</td>
<td>App 端用户登录接口</td>
<td>权限校验、SQL 注入防护</td>
<td>敏感数据加密（密码传输加密）🔒</td>
</tr>
</tbody></table>
<hr>
<h1 id="🔁-接口测试的流程与用例设计"><a href="#🔁-接口测试的流程与用例设计" class="headerlink" title="🔁 接口测试的流程与用例设计"></a>🔁 接口测试的流程与用例设计</h1><h3 id="1️⃣-熟悉接口"><a href="#1️⃣-熟悉接口" class="headerlink" title="1️⃣ 熟悉接口"></a>1️⃣ 熟悉接口</h3><ul>
<li><p>获取方式：<br>○ 查看接口文档<br>○ 抓包工具（如 Charles&#x2F;Fiddler）观察请求</p>
</li>
<li><p>熟悉内容：<br>○ 接口地址、请求方式（GET&#x2F;POST等）<br>○ 鉴权机制（Token&#x2F;Cookie）<br>○ 请求参数与响应结构<br>○ 状态码及错误码定义</p>
</li>
</ul>
<hr>
<h3 id="2️⃣-编写接口测试用例"><a href="#2️⃣-编写接口测试用例" class="headerlink" title="2️⃣ 编写接口测试用例"></a>2️⃣ 编写接口测试用例</h3><ul>
<li><p>用例设计思路：</p>
<ul>
<li><p>正例：<br>○ 合理入参 + 正确鉴权 → 返回成功结果</p>
</li>
<li><p>反例：<br>○ 鉴权类：Token 缺失、错误、过期<br>○ 参数类：参数为空、格式错误、类型&#x2F;长度不符<br>○ 业务类：错误码验证、边界值、分页逻辑<br>○ 安全类：黑名单用户、访问频率限制、权限验证</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3️⃣-执行接口测试"><a href="#3️⃣-执行接口测试" class="headerlink" title="3️⃣ 执行接口测试"></a>3️⃣ 执行接口测试</h3><ul>
<li>使用 Postman 编写请求，管理集合和环境变量</li>
<li>手动调试，确认功能逻辑正确</li>
</ul>
<hr>
<h3 id="4️⃣-持续集成"><a href="#4️⃣-持续集成" class="headerlink" title="4️⃣ 持续集成"></a>4️⃣ 持续集成</h3><ul>
<li>使用 Newman 执行 Postman 脚本</li>
<li>将测试集成至 Jenkins 流水线，输出测试报告，并通过邮件&#x2F;钉钉同步结果 📩</li>
</ul>
<hr>
<h1 id="🧰-Postman-简介与介绍"><a href="#🧰-Postman-简介与介绍" class="headerlink" title="🧰 Postman 简介与介绍"></a>🧰 Postman 简介与介绍</h1><h2 id="界面说明"><a href="#界面说明" class="headerlink" title="界面说明"></a>界面说明</h2><ul>
<li>Home：主页</li>
<li>Workspaces：工作空间管理</li>
<li>Collections：接口集合管理</li>
<li>APIs：API 文档管理</li>
<li>Environments：环境变量与全局变量</li>
<li>Mock Server：虚拟服务器</li>
<li>Monitors：定时监控器</li>
<li>History：历史请求记录</li>
</ul>
<hr>
<h2 id="请求页面说明"><a href="#请求页面说明" class="headerlink" title="请求页面说明"></a>请求页面说明</h2><ul>
<li><p>Params：GET 请求参数</p>
</li>
<li><p>Authorization：设置 Token、Basic Auth 等鉴权方式</p>
</li>
<li><p>Headers：请求头（如 Content-Type、Cookie 等）</p>
</li>
<li><p>Body（POST 请求参数）：</p>
<ul>
<li>none：不传参数</li>
<li>form-data：支持键值对和文件</li>
<li>x-www-form-urlencoded：表单键值对</li>
<li>raw：json、text、xml、html、JavaScript、text等原始格式</li>
<li>binary：文件上传（二进制）</li>
</ul>
</li>
<li><p>pre-request script：请求前执行 JS 脚本</p>
</li>
<li><p>tests：请求后执行断言</p>
</li>
<li><p>cookies：管理 Cookie 信息</p>
</li>
</ul>
<hr>
<h2 id="响应页签说明"><a href="#响应页签说明" class="headerlink" title="响应页签说明"></a>响应页签说明</h2><ul>
<li><p>Body：返回内容</p>
</li>
<li><p>Pretty：以 Json、html、XML 等格式查看数据</p>
</li>
<li><p>Raw：文本方式查看数据</p>
</li>
<li><p>Preview：网页方式查看数据</p>
</li>
<li><p>Cookies：响应中返回的 Cookie</p>
</li>
<li><p>Headers：响应头</p>
</li>
<li><p>Test Results：断言执行结果</p>
</li>
<li><p>状态码与响应信息：</p>
<ul>
<li>200：OK</li>
<li>响应时间（如 681ms）</li>
<li>响应大小（如 343B）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Get请求和Post请求的区别"><a href="#Get请求和Post请求的区别" class="headerlink" title="Get请求和Post请求的区别"></a>Get请求和Post请求的区别</h2><ol>
<li>get 请求一般是获取数据，post 请求一般是提交数据。</li>
<li>post 请求比 get 请求更安全。</li>
<li>本质区别是传参方式不同：</li>
</ol>
<ul>
<li>get 请求在地址栏后面以 ? 方式传参，多个参数用 &amp; 分隔。</li>
<li>post 请求在 body 以表单方式传参。</li>
</ul>
<hr>
<h1 id="环境变量与全局变量"><a href="#环境变量与全局变量" class="headerlink" title="环境变量与全局变量"></a>环境变量与全局变量</h1><ul>
<li>环境变量：限定于特定环境（如 dev&#x2F;test&#x2F;prod），variable 命名必须一致，接口地址中使用 。</li>
<li>全局变量：所有环境、所有接口共享，跨接口共享数据（如登录 Token、用户 ID）。</li>
<li>获取环境变量和全局变量的值通过 。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用域</th>
<th>典型用途</th>
<th>优先级（冲突时）</th>
</tr>
</thead>
<tbody><tr>
<td>环境变量</td>
<td>限定于特定环境</td>
<td>不同环境的配置差异（API 域名、端口）</td>
<td>高于全局变量</td>
</tr>
<tr>
<td>全局变量</td>
<td>所有环境共享</td>
<td>跨接口共享数据</td>
<td>低于环境变量</td>
</tr>
</tbody></table>
<hr>
<h1 id="接口关联"><a href="#接口关联" class="headerlink" title="接口关联"></a>接口关联</h1><h3 id="JSON-提取器"><a href="#JSON-提取器" class="headerlink" title="JSON 提取器"></a>JSON 提取器</h3><p>第一个接口:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用json提取器提取accesss_token值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把返回的字符串格式的数据转换成对象的形式。</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(responseBody);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把access_token设置为全局变量</span></span><br><span class="line">pm.<span class="property">globals</span>.<span class="title function_">set</span>(<span class="string">&quot;access_token&quot;</span>,result.<span class="property">access_tokern</span>);</span><br></pre></td></tr></table></figure>

<p>第二个接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;access_token&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="正则表达式提取器"><a href="#正则表达式提取器" class="headerlink" title="正则表达式提取器"></a>正则表达式提取器</h3><p>第一个接口:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用正则表达式提取器实现接口关联,match匹配。</span></span><br><span class="line"><span class="keyword">var</span> result = responseBody.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;&quot;access_token&quot;:&quot;(.*?)&quot;&#x27;</span>)) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//设置为全局变量</span></span><br><span class="line">pm.<span class="property">globals</span>.<span class="title function_">set</span>(<span class="string">&quot;access_token&quot;</span>,result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>第二个接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;access_token&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="⚡-动态参数"><a href="#⚡-动态参数" class="headerlink" title="⚡ 动态参数"></a>⚡ 动态参数</h1><p>Postman 内置动态参数：</p>
<h3 id="1-时间与日期类-⏰"><a href="#1-时间与日期类-⏰" class="headerlink" title="1. 时间与日期类 ⏰"></a>1. 时间与日期类 ⏰</h3><table>
<thead>
<tr>
<th>参数</th>
<th>格式示例</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1689345678（秒级）</td>
<td>生成当前时间戳（如签名计算）</td>
</tr>
<tr>
<td></td>
<td>2025-06-18T12:34:56Z</td>
<td>随机日期（测试订单有效期）</td>
</tr>
<tr>
<td></td>
<td>2025-06-18T12:34:56.789Z</td>
<td>符合 ISO 8601 格式的时间戳</td>
</tr>
</tbody></table>
<p><strong>使用方法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 pre-request script 中组合参数</span></span><br><span class="line">pm.<span class="property">environment</span>.<span class="title function_">set</span>(<span class="string">&quot;orderId&quot;</span>, <span class="string">&quot;ORD_&quot;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line"><span class="comment">// 请求 URL 中使用：https://api.com/order/&#123;&#123;orderId&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-随机数据类-🎲"><a href="#2-随机数据类-🎲" class="headerlink" title="2. 随机数据类 🎲"></a>2. 随机数据类 🎲</h3><table>
<thead>
<tr>
<th>参数</th>
<th>格式示例</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>345（0-1000 内随机数）</td>
<td>测试分页大小（如 size&#x3D;）</td>
</tr>
<tr>
<td></td>
<td>abcdef12345（16 位随机字符串）</td>
<td>生成随机用户名</td>
</tr>
<tr>
<td></td>
<td>5f7d3a9c-1b2e-4c3d-8e9f-0a1b2c3d4e5f</td>
<td>唯一标识符（测试分布式 ID）</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-模拟数据类-🧪"><a href="#3-模拟数据类-🧪" class="headerlink" title="3. 模拟数据类 🧪"></a>3. 模拟数据类 🧪</h3><table>
<thead>
<tr>
<th>参数</th>
<th>格式示例</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a href="mailto:&#x75;&#115;&#101;&#114;&#53;&#54;&#55;&#64;&#x65;&#x78;&#97;&#x6d;&#x70;&#x6c;&#101;&#46;&#99;&#111;&#109;">user567@example.com</a></td>
<td>注册测试（随机邮箱）</td>
</tr>
<tr>
<td></td>
<td>+1 (555) 123-4567</td>
<td>测试短信验证码接口</td>
</tr>
<tr>
<td></td>
<td>4111 1111 1111 1111</td>
<td>支付模拟（需配合 Mock Server）</td>
</tr>
</tbody></table>
<hr>
<h3 id="自定义动态参数"><a href="#自定义动态参数" class="headerlink" title="自定义动态参数"></a>自定义动态参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动获得时间戳</span></span><br><span class="line"><span class="keyword">var</span> times = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="comment">// 设置为全局变量</span></span><br><span class="line">pm.<span class="property">globals</span>.<span class="title function_">set</span>(<span class="string">&quot;times&quot;</span>, times);</span><br></pre></td></tr></table></figure>

<p><strong>使用时调用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;times&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="📊-Postman-断言"><a href="#📊-Postman-断言" class="headerlink" title="📊 Postman 断言"></a>📊 Postman 断言</h1><h2 id="常规六种断言"><a href="#常规六种断言" class="headerlink" title="常规六种断言"></a>常规六种断言</h2><h3 id="1-Status-code：Code-is-200（状态码断言）✅"><a href="#1-Status-code：Code-is-200（状态码断言）✅" class="headerlink" title="1. Status code：Code is 200（状态码断言）✅"></a>1. Status code：Code is 200（状态码断言）✅</h3><p><strong>作用：</strong> 验证接口返回的 HTTP 状态码是否符合预期（如 200、404 等）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;状态码应为 200&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>扩展场景：</strong></p>
<ul>
<li>验证客户端错误（4xx）：<code>pm.response.to.have.status(401)</code>（未授权）；</li>
<li>验证服务器错误（5xx）：<code>pm.response.to.have.status(500)</code>（内部错误）。</li>
</ul>
<hr>
<h3 id="2-Responsebody：Contains-string（响应体包含字符串断言）🔍"><a href="#2-Responsebody：Contains-string（响应体包含字符串断言）🔍" class="headerlink" title="2. Responsebody：Contains string（响应体包含字符串断言）🔍"></a>2. Responsebody：Contains string（响应体包含字符串断言）🔍</h3><p><strong>作用：</strong> 检查响应内容是否包含指定字符串（支持文本、JSON、XML 等格式）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应体包含 success&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>()).<span class="property">to</span>.<span class="title function_">include</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>若响应为 JSON，需先通过 <code>pm.response.json()</code> 解析；</li>
<li>区分大小写（如 “Success” 与 “success” 不同），可通过 <code>to.include(&quot;success&quot;, &#123;ignoreCase: true&#125;)</code> 忽略大小写。</li>
</ul>
<hr>
<h3 id="3-Responsebody：Json-value-check（JSON-值断言）🧾"><a href="#3-Responsebody：Json-value-check（JSON-值断言）🧾" class="headerlink" title="3. Responsebody：Json value check（JSON 值断言）🧾"></a>3. Responsebody：Json value check（JSON 值断言）🧾</h3><p><strong>作用：</strong> 验证响应 JSON 中特定字段的值是否符合预期。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;用户 ID 应为 123&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> responseJson = pm.<span class="property">response</span>.<span class="title function_">json</span>();</span><br><span class="line">    pm.<span class="title function_">expect</span>(responseJson.<span class="property">user</span>.<span class="property">id</span>).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="number">123</span>);  <span class="comment">// 严格等于</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>多层嵌套场景：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应结构：&#123; &quot;data&quot;: &#123; &quot;list&quot;: [&#123;&quot;id&quot;: &quot;ORD001&quot;&#125;] &#125; &#125;</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;第一个订单 ID 正确&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = pm.<span class="property">response</span>.<span class="title function_">json</span>().<span class="property">data</span>.<span class="property">list</span>[<span class="number">0</span>].<span class="property">id</span>;</span><br><span class="line">    pm.<span class="title function_">expect</span>(id).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="string">&quot;ORD001&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-Responsebody：is-equal-to-a-string（响应体等于字符串断言）📏"><a href="#4-Responsebody：is-equal-to-a-string（响应体等于字符串断言）📏" class="headerlink" title="4. Responsebody：is equal to a string（响应体等于字符串断言）📏"></a>4. Responsebody：is equal to a string（响应体等于字符串断言）📏</h3><p><strong>作用：</strong> 验证响应内容与指定字符串完全一致（较少使用，因响应常含动态数据）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应体等于指定字符串&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>()).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="string">&#x27;&#123;&quot;status&quot;: &quot;ok&quot;&#125;&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>优化建议：</strong></p>
<ul>
<li>避免直接断言完整响应体，可拆分字段断言；</li>
<li>对动态字段（如时间戳）使用通配符或正则表达式（需结合 Chai 库）。</li>
</ul>
<hr>
<h3 id="5-Response-headers：Content-Type…（响应头断言）📋"><a href="#5-Response-headers：Content-Type…（响应头断言）📋" class="headerlink" title="5. Response headers：Content-Type…（响应头断言）📋"></a>5. Response headers：Content-Type…（响应头断言）📋</h3><p><strong>作用：</strong> 检查响应头是否包含指定字段（如 Content-Type、Authorization）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 断言存在 Content-Type 头</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应头包含 Content-Type&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言 Content-Type 为 JSON 格式</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;Content-Type 应为 application/json&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-Response-time-is-less-than-200ms（响应时间断言）⏱️"><a href="#6-Response-time-is-less-than-200ms（响应时间断言）⏱️" class="headerlink" title="6. Response time is less than 200ms（响应时间断言）⏱️"></a>6. Response time is less than 200ms（响应时间断言）⏱️</h3><p><strong>作用：</strong> 验证接口响应时间是否小于指定毫秒数（用于性能初步测试）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应时间应小于 200ms&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="property">responseTime</span>).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">below</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>扩展用法：</strong></p>
<ul>
<li>断言响应时间在区间内：<code>pm.expect(responseTime).to.be.within(100, 300)</code>；</li>
<li>结合环境变量动态设置阈值：<code>pm.expect(responseTime).to.be.below(pm.environment.get(&quot;maxResponseTime&quot;))</code>。</li>
</ul>
<hr>
<h1 id="🔧-在断言中获取自定义动态参数的方式"><a href="#🔧-在断言中获取自定义动态参数的方式" class="headerlink" title="🔧 在断言中获取自定义动态参数的方式"></a>🔧 在断言中获取自定义动态参数的方式</h1><table>
<thead>
<tr>
<th>获取方式</th>
<th>语法示例</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>pm.globals.get(“参数名”)</td>
<td>pm.globals.get(“times”)</td>
<td>推荐通用写法，兼容性强</td>
<td>需通过 pm 上下文调用，适用于 Pre-request Script、Tests 脚本</td>
</tr>
<tr>
<td>globals[“参数名”]</td>
<td>globals[“times”]</td>
<td>键名动态拼接场景</td>
<td>旧版本 Postman 可能不支持</td>
</tr>
<tr>
<td>globals.参数名</td>
<td>globals.times</td>
<td>键名无特殊字符时简写</td>
<td>参数名含特殊字符需用方括号访问</td>
</tr>
</tbody></table>
<hr>
<h1 id="🌍-全局断言"><a href="#🌍-全局断言" class="headerlink" title="🌍 全局断言"></a>🌍 全局断言</h1><h2 id="实现全局断言的三种方案"><a href="#实现全局断言的三种方案" class="headerlink" title="实现全局断言的三种方案"></a>实现全局断言的三种方案</h2><h3 id="方案-1：在-Collection-中编写公共测试脚本"><a href="#方案-1：在-Collection-中编写公共测试脚本" class="headerlink" title="方案 1：在 Collection 中编写公共测试脚本"></a>方案 1：在 Collection 中编写公共测试脚本</h3><p><strong>原理：</strong> 在 Collection 的 Tests 标签页中编写断言，对集合内所有接口生效。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;全局状态码校验&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">be</span>.<span class="property">success</span>;  <span class="comment">// 断言状态码为2xx</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;全局响应头校验&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;Content-Type&quot;</span>)).<span class="property">to</span>.<span class="title function_">include</span>(<span class="string">&quot;json&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>集合级断言优先级低于单个接口断言；</li>
<li>可用 <code>pm.info.requestName</code> 判断接口名，实现条件断言：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pm.<span class="property">info</span>.<span class="property">requestName</span> !== <span class="string">&quot;健康检查接口&quot;</span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);  <span class="comment">// 排除特定接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方案-2：使用前置脚本（Pre-request-Script）动态注入断言"><a href="#方案-2：使用前置脚本（Pre-request-Script）动态注入断言" class="headerlink" title="方案 2：使用前置脚本（Pre-request Script）动态注入断言"></a>方案 2：使用前置脚本（Pre-request Script）动态注入断言</h3><p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Collection 或 Folder 的 Pre-request Script 中添加</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addGlobalAssertion</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 动态生成断言代码字符串</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">        pm.test(&quot;全局响应时间校验&quot;, function() &#123;</span></span><br><span class="line"><span class="string">            pm.expect(pm.response.responseTime).to.be.below(<span class="subst">$&#123;pm.environment.get(<span class="string">&quot;maxResponseTime&quot;</span>) || <span class="number">1000</span>&#125;</span>);</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="comment">// 将断言代码注入到当前请求的 Tests 中</span></span><br><span class="line">    pm.<span class="title function_">test</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件执行（如仅在非本地环境执行）</span></span><br><span class="line"><span class="keyword">if</span> (pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;envType&quot;</span>) !== <span class="string">&quot;local&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">addGlobalAssertion</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方案-3：通过-Newman-命令行添加全局断言"><a href="#方案-3：通过-Newman-命令行添加全局断言" class="headerlink" title="方案 3：通过 Newman 命令行添加全局断言"></a>方案 3：通过 Newman 命令行添加全局断言</h3><p><strong>原理：</strong> Newman 运行时通过脚本参数注入全局断言。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newman-run.js 脚本内容</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Collection</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;postman-collection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">beforeRun</span>: <span class="function">(<span class="params">collection</span>) =&gt;</span> &#123;</span><br><span class="line">        collection.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">request</span>) &#123;</span><br><span class="line">                item.<span class="property">test</span> = <span class="keyword">new</span> <span class="title class_">Collection</span>.<span class="title class_">ItemTest</span>(&#123;</span><br><span class="line">                    <span class="attr">script</span>: &#123;</span><br><span class="line">                        <span class="attr">exec</span>: [</span><br><span class="line">                            <span class="string">&quot;pm.test(\&quot;全局状态码校验\&quot;, function() &#123;&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;    pm.response.to.be.success;&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;&#125;);&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;pm.test(\&quot;全局响应头校验\&quot;, function() &#123;&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;    pm.response.to.have.header(\&quot;X-Request-ID\&quot;);&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;&#125;);&quot;</span></span><br><span class="line">                        ].<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>执行命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newman run collection.json --script newman-run.js</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="全局断言与局部断言的优先级控制"><a href="#全局断言与局部断言的优先级控制" class="headerlink" title="全局断言与局部断言的优先级控制"></a>全局断言与局部断言的优先级控制</h2><table>
<thead>
<tr>
<th>断言位置</th>
<th>优先级</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>单个接口的 Tests</td>
<td>最高</td>
<td>针对特定接口的特殊验证</td>
</tr>
<tr>
<td>Folder 级 Tests</td>
<td>中</td>
<td>分组接口的公共验证</td>
</tr>
<tr>
<td>Collection 级 Tests</td>
<td>最低</td>
<td>全量接口的基础验证（状态码、响应头）</td>
</tr>
</tbody></table>
<p><strong>冲突解决方案：</strong><br>接口级 Tests 中使用 <code>pm.test.remove()</code> 移除不需要的全局断言：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除集合中的全局响应时间断言</span></span><br><span class="line">pm.<span class="property">test</span>.<span class="title function_">remove</span>(<span class="string">&quot;全局响应时间校验&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🧪-Postman-批量运行测试用例"><a href="#🧪-Postman-批量运行测试用例" class="headerlink" title="🧪 Postman 批量运行测试用例"></a>🧪 Postman 批量运行测试用例</h1><p>在 Postman 中批量运行测试用例，主要通过 Collection Runner 功能来实现，以下是具体步骤：</p>
<h2 id="1-创建集合和组织用例"><a href="#1-创建集合和组织用例" class="headerlink" title="1. 创建集合和组织用例"></a>1. 创建集合和组织用例</h2><ul>
<li>点击左侧 “Collections” 的 “➕” 按钮创建集合，输入集合名称。</li>
<li>选中集合点击 “⋯” → <strong>Add Folder</strong> 添加模块文件夹。</li>
<li>再选中文件夹点击 <strong>Add Request</strong> 添加接口测试用例，配置请求参数、断言脚本，将接口组织到集合中。</li>
</ul>
<h3 id="2-选择运行方式"><a href="#2-选择运行方式" class="headerlink" title="2. 选择运行方式"></a>2. 选择运行方式</h3><ul>
<li>✅ 点击集合右上角 <strong>Run</strong>：全模块回归测试。</li>
<li>✅ 点击文件夹右上角 <strong>Run folder</strong>：单模块迭代测试。</li>
</ul>
<h3 id="3-配置-Runner-参数"><a href="#3-配置-Runner-参数" class="headerlink" title="3. 配置 Runner 参数"></a>3. 配置 Runner 参数</h3><ul>
<li><p><strong>Iterations</strong>：设置测试迭代次数。</p>
</li>
<li><p><strong>Delay</strong>：设置接口调用间隔（单位：ms）。</p>
</li>
<li><p><strong>Data</strong>：导入 CSV &#x2F; JSON 文件进行参数化。</p>
</li>
<li><p><strong>Advanced settings</strong>：</p>
<ul>
<li>✅ 勾选 “Persist responses” 保存响应。</li>
<li>🔁 选择 “Run order” 控制执行顺序（按文件夹顺序或随机执行）。</li>
</ul>
</li>
</ul>
<h3 id="4-执行批量测试"><a href="#4-执行批量测试" class="headerlink" title="4. 执行批量测试"></a>4. 执行批量测试</h3><p>点击 <strong>Run</strong> 或 <strong>Run 文件夹名称</strong> 按钮，即可批量运行测试用例。</p>
<h3 id="5-分析运行结果"><a href="#5-分析运行结果" class="headerlink" title="5. 分析运行结果"></a>5. 分析运行结果</h3><ul>
<li>📊 汇总信息：运行时间、迭代次数、通过&#x2F;失败数量、平均响应时间等。</li>
<li>🔍 单接口详情：状态码、响应时间、响应体、断言结果、错误信息。</li>
</ul>
<hr>
<h1 id="📂-Postman-数据驱动测试"><a href="#📂-Postman-数据驱动测试" class="headerlink" title="📂 Postman 数据驱动测试"></a>📂 Postman 数据驱动测试</h1><h2 id="✅-CSV-参数化测试"><a href="#✅-CSV-参数化测试" class="headerlink" title="✅ CSV 参数化测试"></a>✅ CSV 参数化测试</h2><h3 id="📁-CSV-文件格式要求"><a href="#📁-CSV-文件格式要求" class="headerlink" title="📁 CSV 文件格式要求"></a>📁 CSV 文件格式要求</h3><ul>
<li>第一行为表头，后续行为数据。</li>
<li>使用英文逗号 <code>,</code> 分隔，若字段含逗号，需用双引号包裹。</li>
</ul>
<p>示例文件 <code>users.csv</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username,password,expected_status</span><br><span class="line">admin,admin123,200</span><br><span class="line">guest,guest456,200</span><br><span class="line">invalid_user,wrong_pwd,401</span><br></pre></td></tr></table></figure>

<h3 id="📥-导入-CSV-步骤"><a href="#📥-导入-CSV-步骤" class="headerlink" title="📥 导入 CSV 步骤"></a>📥 导入 CSV 步骤</h3><ol>
<li>Runner 中选择集合或文件夹 → 点击 <strong>Select File</strong>。</li>
<li>选择 CSV 文件 → Postman 自动识别变量名并预览数据。</li>
</ol>
<h3 id="🔗-请求中引用变量"><a href="#🔗-请求中引用变量" class="headerlink" title="🔗 请求中引用变量"></a>🔗 请求中引用变量</h3><ul>
<li><p>URL 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.com/login?username=&#123;&#123;username&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>请求体参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#123;username&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#123;password&#125;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在断言中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;状态码校验&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(pm.<span class="property">iterationData</span>.<span class="title function_">get</span>(<span class="string">&quot;expected_status&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="✅-JSON-参数化测试"><a href="#✅-JSON-参数化测试" class="headerlink" title="✅ JSON 参数化测试"></a>✅ JSON 参数化测试</h2><h3 id="📁-JSON-文件格式要求"><a href="#📁-JSON-文件格式要求" class="headerlink" title="📁 JSON 文件格式要求"></a>📁 JSON 文件格式要求</h3><ul>
<li>根节点为数组，每组对象为一组测试数据。</li>
</ul>
<p>示例 <code>orders.json</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;productId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;P001&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">99.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expectedTotal&quot;</span><span class="punctuation">:</span> <span class="number">99.9</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;productId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;P002&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">49.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expectedTotal&quot;</span><span class="punctuation">:</span> <span class="number">149.7</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="📥-导入-JSON-步骤"><a href="#📥-导入-JSON-步骤" class="headerlink" title="📥 导入 JSON 步骤"></a>📥 导入 JSON 步骤</h3><ul>
<li>同样在 Runner 中选择 JSON 文件，Postman 自动识别变量。</li>
</ul>
<h3 id="🔗-引用方式示例"><a href="#🔗-引用方式示例" class="headerlink" title="🔗 引用方式示例"></a>🔗 引用方式示例</h3><ul>
<li><p>URL 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.com/order/&#123;&#123;productId&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>请求体参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span>quantity<span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unitPrice&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span>price<span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>JSON 断言：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;金额计算正确&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = pm.<span class="property">response</span>.<span class="title function_">json</span>();</span><br><span class="line">  pm.<span class="title function_">expect</span>(response.<span class="property">total</span>).<span class="property">to</span>.<span class="title function_">eql</span>(pm.<span class="property">iterationData</span>.<span class="title function_">get</span>(<span class="string">&quot;expectedTotal&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="🧾-请求必须携带的请求头说明"><a href="#🧾-请求必须携带的请求头说明" class="headerlink" title="🧾 请求必须携带的请求头说明"></a>🧾 请求必须携带的请求头说明</h1><table>
<thead>
<tr>
<th>请求头名</th>
<th>说明</th>
<th>示例值</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>指定目标主机（HTTP&#x2F;1.1要求）</td>
<td><code>api.example.com</code></td>
</tr>
<tr>
<td>Connection</td>
<td>是否保持长连接</td>
<td><code>keep-alive</code></td>
</tr>
<tr>
<td>Accept</td>
<td>可接受的响应格式</td>
<td><code>application/json</code></td>
</tr>
<tr>
<td>X-Requested-With</td>
<td>是否为 AJAX 请求</td>
<td><code>XMLHttpRequest</code></td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端身份标识</td>
<td><code>Mozilla/5.0...</code></td>
</tr>
<tr>
<td>Referer</td>
<td>请求来源页面 URL</td>
<td><code>https://example.com</code></td>
</tr>
<tr>
<td>Cookie</td>
<td>携带的 Cookie 信息</td>
<td><code>session_id=123456; user_token=abc</code></td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的格式类型</td>
<td><code>application/json</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="🔧-Postman接口Mock-Servier服务器"><a href="#🔧-Postman接口Mock-Servier服务器" class="headerlink" title="🔧 Postman接口Mock Servier服务器"></a>🔧 Postman接口Mock Servier服务器</h1><h2 id="🧪-Mock-Server-核心价值与应用场景"><a href="#🧪-Mock-Server-核心价值与应用场景" class="headerlink" title="🧪 Mock Server 核心价值与应用场景"></a>🧪 Mock Server 核心价值与应用场景</h2><h3 id="核心价值"><a href="#核心价值" class="headerlink" title="核心价值"></a>核心价值</h3><p>解决痛点：后端接口尚未开发完成时，前端可通过 Mock Server 模拟接口响应，实现并行开发，提升开发效率。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>前后端分离开发，后端进度滞后时前端可独立调试</li>
<li>测试复杂业务流程（如支付回调、状态变更）</li>
<li>模拟异常情况（如网络超时、服务器错误）</li>
</ul>
<hr>
<h2 id="⚙️-创建-Mock-Server-全流程（以用户示例为例）"><a href="#⚙️-创建-Mock-Server-全流程（以用户示例为例）" class="headerlink" title="⚙️ 创建 Mock Server 全流程（以用户示例为例）"></a>⚙️ 创建 Mock Server 全流程（以用户示例为例）</h2><h3 id="1-准备-Mock-响应数据"><a href="#1-准备-Mock-响应数据" class="headerlink" title="1. 准备 Mock 响应数据"></a>1. 准备 Mock 响应数据</h3><p>示例 JSON（注意逗号格式）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error_code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;返回成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在-Postman-中创建-Mock-Server"><a href="#2-在-Postman-中创建-Mock-Server" class="headerlink" title="2. 在 Postman 中创建 Mock Server"></a>2. 在 Postman 中创建 Mock Server</h3><p><strong>步骤如下：</strong></p>
<ol>
<li><p>创建 Collection：</p>
<ul>
<li>点击左侧 Collections → ➕ → 命名为“前端 Mock 接口”</li>
<li>添加请求（如 GET&#x2F;POST）→ 命名为“获取数据接口”</li>
</ul>
</li>
<li><p>配置请求与响应：</p>
<ul>
<li>请求 URL 可自定义，如：<code>https://mock-api.com/data/query</code></li>
<li>切换至 Response 标签页 → 选择 <code>raw</code> → 粘贴 JSON</li>
<li>设置状态码为 <code>200 OK</code></li>
</ul>
</li>
<li><p>生成 Mock Server：</p>
<ul>
<li>点击 Collection 的 <code>…</code> → 选择 <code>Generate Mock Server</code></li>
<li>设置域名（如：<code>mock-server.postman.com</code>）</li>
<li>点击 Create Mock → 复制生成的 Mock URL，如：<br><code>https://postman-echo.com/mock/12345/data/query</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-前端调用-Mock-接口示例（JavaScript）"><a href="#3-前端调用-Mock-接口示例（JavaScript）" class="headerlink" title="3. 前端调用 Mock 接口示例（JavaScript）"></a>3. 前端调用 Mock 接口示例（JavaScript）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://postman-echo.com/mock/12345/data/query&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;接口返回:&quot;</span>, data);</span><br><span class="line">  <span class="comment">// 渲染或处理数据</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求错误:&quot;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🍪-Postman-的-Cookie-鉴权机制"><a href="#🍪-Postman-的-Cookie-鉴权机制" class="headerlink" title="🍪 Postman 的 Cookie 鉴权机制"></a>🍪 Postman 的 Cookie 鉴权机制</h1><h2 id="1-Cookie-是什么"><a href="#1-Cookie-是什么" class="headerlink" title="1. Cookie 是什么"></a>1. Cookie 是什么</h2><ul>
<li>由服务器生成的小段 <code>key=value</code> 格式文本</li>
<li>存储在浏览器或 Postman 中，用于身份验证、会话控制等</li>
</ul>
<h2 id="2-鉴权流程"><a href="#2-鉴权流程" class="headerlink" title="2. 鉴权流程"></a>2. 鉴权流程</h2><ol>
<li>当客户端第一次访问服务器的时候,那么服务器就会生成Cookie信息,并且在响应头的set-cookie里面把生成的cookie信息发送给客户端。</li>
<li>当客户端第2-N次访问服务器的时候,那么客户端就会在请求头的cookie带上cookie信息,从而实现鉴权</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">首次请求 → 服务器生成 Set-Cookie 响应头 → 客户端保存 Cookie</span><br><span class="line">↓</span><br><span class="line">后续请求 → 客户端自动附带 Cookie 请求头 → 服务器完成身份校验</span><br></pre></td></tr></table></figure>

<h3 id="3-Cookie-类型对比"><a href="#3-Cookie-类型对比" class="headerlink" title="3. Cookie 类型对比"></a>3. Cookie 类型对比</h3><table>
<thead>
<tr>
<th>类型</th>
<th>存储位置</th>
<th>生命周期</th>
<th>安全性</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>会话 Cookie</td>
<td>内存</td>
<td>浏览器关闭即失效</td>
<td>较低</td>
<td>购物车、临时登录</td>
</tr>
<tr>
<td>持久 Cookie</td>
<td>硬盘</td>
<td>设定的过期时间前有效</td>
<td>较高</td>
<td>记住我、长期登录</td>
</tr>
</tbody></table>
<hr>
<h1 id="🔐-Postman-实现接口加密与解密"><a href="#🔐-Postman-实现接口加密与解密" class="headerlink" title="🔐 Postman 实现接口加密与解密"></a>🔐 Postman 实现接口加密与解密</h1><h2 id="主流加密算法分类"><a href="#主流加密算法分类" class="headerlink" title="主流加密算法分类"></a>主流加密算法分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>代表算法</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>对称加密</td>
<td>AES &#x2F; DES &#x2F; Base64</td>
<td>加解密使用同一密钥，速度快</td>
<td>请求体数据加密</td>
</tr>
<tr>
<td>非对称加密</td>
<td>RSA &#x2F; ECC</td>
<td>公钥加密私钥解密，较安全</td>
<td>数字签名、密钥交换</td>
</tr>
<tr>
<td>单向哈希</td>
<td>MD5 &#x2F; SHA256</td>
<td>不可逆，用于验证完整性</td>
<td>密码存储、数据签名</td>
</tr>
</tbody></table>
<hr>
<h2 id="Postman-中加密实现方式"><a href="#Postman-中加密实现方式" class="headerlink" title="Postman 中加密实现方式"></a>Postman 中加密实现方式</h2><h3 id="✅-使用内置-CryptoJS（推荐）"><a href="#✅-使用内置-CryptoJS（推荐）" class="headerlink" title="✅ 使用内置 CryptoJS（推荐）"></a>✅ 使用内置 CryptoJS（推荐）</h3><p>Postman 内置了 Crypto-js 库，支持 AES、MD5、SHA 等多种加密算法。</p>
<p><strong>AES 加密请求体：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Pre-request Script中添加</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待加密数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥（需与后端保持一致）</span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&quot;1234567890123456&quot;</span>; <span class="comment">// 16字节密钥（AES-128）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AES加密（ECB模式 + PKCS7填充）</span></span><br><span class="line"><span class="keyword">const</span> encrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(data, secretKey, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">&#125;).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置加密后的数据到请求体</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">body</span>.<span class="property">raw</span> = encrypted;</span><br></pre></td></tr></table></figure>

<p><strong>MD5 签名：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Pre-request Script中添加</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待签名数据</span></span><br><span class="line"><span class="keyword">const</span> signData = <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&quot;your-api-secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成MD5签名</span></span><br><span class="line"><span class="keyword">const</span> signature = <span class="title class_">CryptoJS</span>.<span class="title class_">MD5</span>(signData + secretKey).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加签名到请求头</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">headers</span>.<span class="title function_">upsert</span>(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;X-Signature&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: signature</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔄-外部-JS-文件导入"><a href="#🔄-外部-JS-文件导入" class="headerlink" title="🔄 外部 JS 文件导入"></a>🔄 外部 JS 文件导入</h3><p><strong>encrypt.js 文件：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aesEncrypt</span>(<span class="params">data, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(data, key).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方式：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(pm.<span class="property">globals</span>.<span class="title function_">get</span>(<span class="string">&quot;encryptScript&quot;</span>)); <span class="comment">// 从全局变量获取脚本内容</span></span><br><span class="line"><span class="keyword">const</span> encrypted = <span class="title function_">aesEncrypt</span>(<span class="string">&quot;敏感数据&quot;</span>, <span class="string">&quot;密钥&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔍-解密响应数据（Tests-脚本中）"><a href="#🔍-解密响应数据（Tests-脚本中）" class="headerlink" title="🔍 解密响应数据（Tests 脚本中）"></a>🔍 解密响应数据（Tests 脚本中）</h2><h3 id="在-Tests-脚本中解密响应"><a href="#在-Tests-脚本中解密响应" class="headerlink" title="在 Tests 脚本中解密响应"></a>在 Tests 脚本中解密响应</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Tests脚本中添加</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从响应获取加密数据</span></span><br><span class="line"><span class="keyword">const</span> encryptedData = pm.<span class="property">response</span>.<span class="title function_">text</span>();</span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&quot;1234567890123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES解密</span></span><br><span class="line"><span class="keyword">const</span> bytes = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(encryptedData, secretKey);</span><br><span class="line"><span class="keyword">const</span> decryptedData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(bytes.<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言解密后的数据</span></span><br><span class="line">pm.<span class="title function_">expect</span>(decryptedData.<span class="property">code</span>).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="number">0</span>);</span><br><span class="line">pm.<span class="title function_">expect</span>(decryptedData.<span class="property">data</span>.<span class="property">username</span>).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用环境变量存储解密结果"><a href="#使用环境变量存储解密结果" class="headerlink" title="使用环境变量存储解密结果"></a>使用环境变量存储解密结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解密后存储到环境变量供后续请求使用</span></span><br><span class="line">pm.<span class="property">environment</span>.<span class="title function_">set</span>(<span class="string">&quot;decryptedData&quot;</span>, decryptedData);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔐-加密场景示例"><a href="#🔐-加密场景示例" class="headerlink" title="🔐 加密场景示例"></a>🔐 加密场景示例</h2><p><strong>RSA 加密（使用公钥）：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Pre-request Script中添加（需先导入jsrsasign库）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">JSEncrypt</span> = <span class="built_in">require</span>(<span class="string">&#x27;jsencrypt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥（从环境变量获取）</span></span><br><span class="line"><span class="keyword">const</span> publicKey = pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;rsaPublicKey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待加密数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&quot;敏感信息&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">const</span> encrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>();</span><br><span class="line">encrypt.<span class="title function_">setPublicKey</span>(publicKey);</span><br><span class="line"><span class="keyword">const</span> encrypted = encrypt.<span class="title function_">encrypt</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置到请求体</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">body</span>.<span class="property">raw</span> = encrypted;</span><br></pre></td></tr></table></figure>

<p><strong>带时间戳的签名验证：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pre-request Script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> timestamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成签名</span></span><br><span class="line"><span class="keyword">const</span> signData = <span class="string">`timestamp=<span class="subst">$&#123;timestamp&#125;</span>&amp;api_key=your_key`</span>;</span><br><span class="line"><span class="keyword">const</span> signature = <span class="title class_">CryptoJS</span>.<span class="title class_">SHA256</span>(signData + pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;apiSecret&quot;</span>)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到请求头</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">headers</span>.<span class="title function_">upsert</span>(&#123; <span class="attr">key</span>: <span class="string">&quot;X-Timestamp&quot;</span>, <span class="attr">value</span>: timestamp &#125;);</span><br><span class="line">pm.<span class="property">request</span>.<span class="property">headers</span>.<span class="title function_">upsert</span>(&#123; <span class="attr">key</span>: <span class="string">&quot;X-Signature&quot;</span>, <span class="attr">value</span>: signature &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests脚本验证响应签名</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应签名验证&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> responseSign = pm.<span class="property">response</span>.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;X-Response-Sign&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> expectedSign = <span class="title class_">CryptoJS</span>.<span class="title class_">SHA256</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>() + pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;apiSecret&quot;</span>)).<span class="title function_">toString</span>();</span><br><span class="line">    pm.<span class="title function_">expect</span>(responseSign).<span class="property">to</span>.<span class="title function_">eql</span>(expectedSign);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>好的，以下是针对你提供的 <strong>Newman</strong> 相关内容的整理，带有适当表情提示，保持简洁且易读：</p>
<hr>
<h1 id="🚀-Newman"><a href="#🚀-Newman" class="headerlink" title="🚀 Newman"></a>🚀 Newman</h1><h2 id="🚀-Newman-核心价值与应用场景"><a href="#🚀-Newman-核心价值与应用场景" class="headerlink" title="🚀 Newman 核心价值与应用场景"></a>🚀 Newman 核心价值与应用场景</h2><p><strong>定位</strong>：Postman 的命令行运行器，适合自动化执行测试脚本，完美适配 CI&#x2F;CD 流水线。</p>
<p><strong>核心优势</strong>：</p>
<ul>
<li>🖥️ 脱离 GUI，可集成 Jenkins、GitLab CI 等自动化工具</li>
<li>🔄 支持批量运行、参数化测试、生成标准化报告</li>
<li>🌍 跨平台（Linux&#x2F;Windows&#x2F;Mac），支持团队协作</li>
</ul>
<hr>
<h2 id="🛠-Newman-安装与基础使用"><a href="#🛠-Newman-安装与基础使用" class="headerlink" title="🛠 Newman 安装与基础使用"></a>🛠 Newman 安装与基础使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g newman</span><br></pre></td></tr></table></figure>

<p>（需先安装 Node.js）</p>
<h3 id="基础命令结构"><a href="#基础命令结构" class="headerlink" title="基础命令结构"></a>基础命令结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newman run [collection文件路径] [选项参数]</span><br></pre></td></tr></table></figure>

<h3 id="核心参数说明"><a href="#核心参数说明" class="headerlink" title="核心参数说明"></a>核心参数说明</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-e</code></td>
<td>指定环境变量文件 (JSON)</td>
<td><code>-e environments/test.json</code></td>
</tr>
<tr>
<td><code>-g</code></td>
<td>指定全局变量文件 (JSON)</td>
<td><code>-g globals/prod.json</code></td>
</tr>
<tr>
<td><code>-d</code></td>
<td>参数化测试数据文件 (CSV&#x2F;JSON)</td>
<td><code>-d data/users.csv</code></td>
</tr>
<tr>
<td><code>-n</code></td>
<td>迭代次数</td>
<td><code>-n 5</code> （每个用例执行 5 次）</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>报告格式（支持多种组合）</td>
<td><code>-r cli,html,json,junit</code></td>
</tr>
<tr>
<td><code>--reporter-*</code></td>
<td>定制报告输出（如HTML路径）</td>
<td><code>--reporter-html-export reports/result.html</code></td>
</tr>
<tr>
<td><code>--delay-request</code></td>
<td>请求间隔（毫秒）</td>
<td><code>--delay-request 500</code></td>
</tr>
<tr>
<td><code>--insecure</code></td>
<td>允许忽略 HTTPS 证书验证</td>
<td><code>--insecure</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="🏃‍♂️-从-Postman-到-Newman-的完整流程"><a href="#🏃‍♂️-从-Postman-到-Newman-的完整流程" class="headerlink" title="🏃‍♂️ 从 Postman 到 Newman 的完整流程"></a>🏃‍♂️ 从 Postman 到 Newman 的完整流程</h2><h3 id="1-导出-Collection-和-Environment"><a href="#1-导出-Collection-和-Environment" class="headerlink" title="1. 导出 Collection 和 Environment"></a>1. 导出 Collection 和 Environment</h3><ul>
<li>Postman → 选择集合 → 点击 <code>...</code> → Export → 保存为 <code>collection.json</code></li>
<li>选择环境 → 点击 <code>...</code> → Export → 保存为 <code>environment.json</code></li>
</ul>
<h3 id="2-执行基本测试"><a href="#2-执行基本测试" class="headerlink" title="2. 执行基本测试"></a>2. 执行基本测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行集合，使用测试环境变量</span></span><br><span class="line">newman run collection.json -e environment.json</span><br></pre></td></tr></table></figure>

<h3 id="3-参数化测试示例"><a href="#3-参数化测试示例" class="headerlink" title="3. 参数化测试示例"></a>3. 参数化测试示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用CSV数据文件进行参数化测试，生成HTML报告</span></span><br><span class="line">newman run collection.json -e test.env.json -d data/users.csv -n 3 -r html --reporter-html-export reports/test-result.html</span><br></pre></td></tr></table></figure>

<h3 id="4-并发与全局变量示例"><a href="#4-并发与全局变量示例" class="headerlink" title="4. 并发与全局变量示例"></a>4. 并发与全局变量示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟10个并发用户，执行5次迭代，输出JUnit格式报告</span></span><br><span class="line">newman run collection.json -g globals.json -n 5 --concurrency 10 -r junit --reporter-junit-export reports/junit.xml</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🤖-Postman-Newman-Jenkins-持续集成实战"><a href="#🤖-Postman-Newman-Jenkins-持续集成实战" class="headerlink" title="🤖 Postman + Newman + Jenkins 持续集成实战"></a>🤖 Postman + Newman + Jenkins 持续集成实战</h1><h2 id="核心步骤速览"><a href="#核心步骤速览" class="headerlink" title="核心步骤速览"></a>核心步骤速览</h2><ol>
<li><p>环境准备</p>
<ul>
<li>安装 Jenkins（推荐 Docker 部署）</li>
<li>安装 Node.js 和 Newman（Jenkins 节点）</li>
<li>导出 Postman Collection 和环境变量文件</li>
</ul>
</li>
<li><p>Jenkins 配置</p>
<ul>
<li>新建自由风格项目</li>
<li>配置 Git 源码管理</li>
<li>添加构建步骤，执行 Newman 命令</li>
</ul>
</li>
<li><p>报告集成</p>
<ul>
<li>安装 HTML Publisher 插件</li>
<li>配置报告路径</li>
<li>保存并触发构建</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🖥-详细操作步骤"><a href="#🖥-详细操作步骤" class="headerlink" title="🖥 详细操作步骤"></a>🖥 详细操作步骤</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker安装 Jenkins（推荐）</span></span><br><span class="line">docker run -d -p 8080:8080 -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Jenkins节点安装 Newman</span></span><br><span class="line">npm install -g newman newman-reporter-html</span><br></pre></td></tr></table></figure>

<ul>
<li>导出 Postman Collection（<code>collection.json</code>）与环境变量文件（<code>environment.json</code>）</li>
</ul>
<hr>
<h3 id="Jenkins-项目配置"><a href="#Jenkins-项目配置" class="headerlink" title="Jenkins 项目配置"></a>Jenkins 项目配置</h3><ol>
<li><p>新建项目</p>
<ul>
<li>点击 New Item → 输入项目名 → 选择 Freestyle project</li>
</ul>
</li>
<li><p>源码管理</p>
<ul>
<li>选择 Git → 输入仓库地址 → 配置认证信息</li>
</ul>
</li>
<li><p>构建步骤</p>
<ul>
<li>添加 Execute shell（Linux&#x2F;macOS）：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newman run collection.json \</span><br><span class="line">  -e environment.json \</span><br><span class="line">  -r html \</span><br><span class="line">  --reporter-html-export reports/index.html</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>构建后操作</p>
<ul>
<li><p>添加 Publish HTML reports 插件配置</p>
<ul>
<li>Report name: API测试报告</li>
<li>Directory: reports</li>
<li>Index page: index.html</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🔍-关键命令解析"><a href="#🔍-关键命令解析" class="headerlink" title="🔍 关键命令解析"></a>🔍 关键命令解析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newman run collection.json \</span><br><span class="line">  -e environment.json \          <span class="comment"># 环境变量</span></span><br><span class="line">  -d data.csv \                  <span class="comment"># 参数化测试数据（可选）</span></span><br><span class="line">  -n 5 \                        <span class="comment"># 迭代次数（可选）</span></span><br><span class="line">  -r html \                     <span class="comment"># 生成HTML报告</span></span><br><span class="line">  --reporter-html-export reports/index.html  <span class="comment"># 报告路径</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚠️-常见问题及解决方案"><a href="#⚠️-常见问题及解决方案" class="headerlink" title="⚠️ 常见问题及解决方案"></a>⚠️ 常见问题及解决方案</h2><table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>Newman 未找到</td>
<td>检查 Node.js 与 Newman 是否安装，或使用绝对路径（如 <code>/usr/bin/newman</code>）</td>
</tr>
<tr>
<td>报告为空</td>
<td>确认命令中的报告路径与 Jenkins 配置一致，确认 Newman 执行成功</td>
</tr>
<tr>
<td>中文乱码</td>
<td>添加参数 <code>--reporter-html-encoding utf-8</code></td>
</tr>
<tr>
<td>环境变量不生效</td>
<td>确保 <code>environment.json</code> 格式正确，变量名与 Postman 一致</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-执行效果验证"><a href="#✅-执行效果验证" class="headerlink" title="✅ 执行效果验证"></a>✅ 执行效果验证</h2><ol>
<li>触发 Jenkins 构建</li>
<li>构建成功后，点击左侧菜单中的 “API测试报告”</li>
<li>查看测试结果（成功率、响应时间、失败用例）</li>
</ol>
<hr>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过本次系统性学习，我对接口测试从原理、流程、工具到自动化的整个链路有了清晰的认识，Postman 不仅适合手动调试，还可以搭配 Newman 实现完整的自动化方案，未来在项目中我也会持续将这些方法应用于实践中。</p>
<p>如果你刚入门接口测试，希望这份整理对你有所帮助，也欢迎交流、讨论更多实战经验 🙌。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Linn0813.github.io">yuxiaoling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://linn0813.github.io/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-06-20-postman-class/">https://linn0813.github.io/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-06-20-postman-class/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">版权所有，转载请注明出处。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><a class="post-meta__tags" href="/tags/Postman/">Postman</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a><a class="post-meta__tags" href="/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/">接口测试</a><a class="post-meta__tags" href="/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/">测试用例</a><a class="post-meta__tags" href="/tags/Newman/">Newman</a><a class="post-meta__tags" href="/tags/Mock-Server/">Mock Server</a></div><div class="post-share"><div class="social-share" data-image="/img/postman-class.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/2025-06-19-bug-reporting-guide/" title="已测试工程师视角：如何优雅提 Bug，让开发主动修复？😎"><img class="cover" src="/img/bug-reporting-guide.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">已测试工程师视角：如何优雅提 Bug，让开发主动修复？😎</div></div><div class="info-2"><div class="info-item-1">已测试工程师视角：如何优雅提 Bug，让开发主动修复？😎 作为上一篇博文《🌟 Bug 责任端快速定位实战指南：从传统方法到 AI 辅助》的进一步分享，本文聚焦测试工程师如何高效、优雅地提 Bug，提升开发响应速度和修复意愿。作为一名测试岗位的一员，我曾因 Bug 描述不清被开发质疑“复现不了”，也曾因沟通不到位陷入协作瓶颈。但通过总结和实践，我找到了一套按端拆解的提 Bug 实战技巧，帮助我大幅提升 Bug 修复效率。   一、清晰、准确地描述 Bug 🚀Bug 描述是提 Bug 的核心，不同负责端的 Bug 在描述时有各自的重点，务必做到简洁明了、逻辑清晰。 （一）前端 Bug 详细复现步骤：按操作顺序列出，精确到每个交互动作和时间间隔。例如：  打开网页，等待页面完全加载； 点击顶部导航栏「用户中心」按钮，快速连续点击 3 次； 观察到页面出现白屏，无法显示用户信息。   明确环境信息：除常规系统、浏览器信息，还要标注屏幕分辨率、缩放比例等。例如：「Windows 11 系统，Chrome 115 浏览器，分辨率 1920×1080，页面缩放...</div></div></div></a><a class="pagination-related" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7/2025-06-23-cursor-hack/" title="🎉 超全！Cursor Pro 白嫖指南 😎"><img class="cover" src="/img/cursor-hack.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">🎉 超全！Cursor Pro 白嫖指南 😎</div></div><div class="info-2"><div class="info-item-1">🎉 超全！Cursor Pro 白嫖指南 😎🧠 Cursor 软件：功能简介与优势 🚀Cursor 是一款基于 VS Code 内核的 AI 编程助手，通过深度整合大语言模型（如 OpenAI GPT 系列），为开发者提供从代码补全、重构到调试建议的一站式智能支持。它不仅能根据自然语言指令生成代码片段，还能在复杂项目中理解上下文，帮助你快速定位和修复问题。 ✨ 核心优势一览 ✨  自然语言驱动 🗣️你可以用一句“请帮我添加一个排序算法”，Cursor 会自动生成对应代码，无需手动查文档。 上下文感知超长片段 📚支持超过 10k 字的项目上下文扫描，尤其在大型微服务或多文件协同项目里，智能补全更准确。 实时调试对话 🐞💬在 IDE 中直接发起调试会话，Cursor 能分析错误栈、给出修复建议，还能生成单元测试骨架。 丰富插件生态 🧩兼容所有 VS Code 插件，从主题、Lint，到 Docker，一套工具搞定所有开发场景。 多语言多框架支持 🌐开箱即用 Python、JavaScript、TypeScript、Go、Java、C++ 等主流语言，以及...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-05-18-postman/" title="📨 Postman 使用指南 —— 测试工程师的快乐源泉"><img class="cover" src="/img/postman.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-18</div><div class="info-item-2">📨 Postman 使用指南 —— 测试工程师的快乐源泉</div></div><div class="info-2"><div class="info-item-1">📨 Postman 使用指南 —— 测试工程师的快乐源泉🎉 前言作为一名测试工程师，我们的日常离不开 Postman。它不仅是接口测试的神器，还是 Debug 的利器，甚至能拯救你的加班生活！ 如果你还没用过 Postman，或者用得不够 6，那就跟我一起探索它的魅力吧！  🤔 什么是 Postman？Postman 是一个强大的 API 开发与测试工具，它可以帮助开发人员和测试人员更高效地与 API 交互。它提供了一个用户友好的界面，让你可以轻松发送请求、检查响应、编写测试脚本，甚至进行自动化测试。  🔥 Postman 的核心优势 简单直观：可视化界面，降低 API 调试难度 支持多种请求类型：GET、POST、PUT、DELETE、PATCH 等 环境变量管理：一键切换不同测试环境，减少手动修改的烦恼 自动化测试：可编写 JavaScript 脚本来自动检查接口响应 接口集合（Collections）：批量管理请求，提高工作效率 Mock 服务：模拟 API 响应，适用于前端开发调试 团队协作：共享 API 文档、测试用例，提高团队协作效率   🚀 1. 安装...</div></div></div></a><a class="pagination-related" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%93%E7%B3%BB/2025-06-30-pytest/" title="🧪pytest 自动化测试框架学习笔记｜结合两个优质视频总结"><img class="cover" src="/img/pytest.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="info-item-2">🧪pytest 自动化测试框架学习笔记｜结合两个优质视频总结</div></div><div class="info-2"><div class="info-item-1">🧪pytest 自动化测试框架学习笔记｜结合两个优质视频总结 本文是我基于两个 B 站教学视频的混合学习笔记总结而成：  🎥 白月黑羽编程 Pytest 自动化测试框架 🎥 码尚教育 Pytest 自动化实战全流程  第一部视频讲解简洁清晰，适合快速入门；第二部内容更系统，涵盖 YAML、Allure、关键字驱动等进阶技巧。为避免重复，我将两个视频内容合理整合，输出这份系统化的 Pytest 学习笔记与实战指南，适合初学者查阅，也适合有经验的测试人员查漏补缺。   📌 一、Pytest 框架简介与核心优势Pytest 是 Python 中最流行的单元测试框架之一，也是许多接口自动化框架的基础组件。 核心特点：  ✅ 语法简洁：用 assert 就能断言 ✅ 自动发现用例：命名规则清晰 ✅ 插件丰富：支持 HTML 报告、多线程执行、失败重试等 ✅ 数据驱动支持：原生支持 @pytest.mark.parametrize ✅ 兼容 unittest，支持灵活前后置处理（fixture）   🚀 二、Pytest 基础实战与项目规范✅ 1. 用例编写与命名规则#...</div></div></div></a><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-05-15-apifox/" title="🚀 Apifox 使用指南 —— 开发 &amp; 测试的效率神器"><img class="cover" src="/img/apifox.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-15</div><div class="info-item-2">🚀 Apifox 使用指南 —— 开发 &amp; 测试的效率神器</div></div><div class="info-2"><div class="info-item-1">🚀 Apifox 使用指南 —— 开发 &amp; 测试的效率神器🎉 前言作为测试工程师，我们每天和 API 打交道，而 Apifox 绝对是接口测试界的“全能战士”！ 它不仅可以 发送 API 请求、管理接口文档、生成 Mock 数据、进行自动化测试，还能一键同步接口数据，让开发和测试效率翻倍！ 在上一期《📨 Postman 使用指南 —— 测试工程师的快乐源泉》中，我们介绍了 Postman 作为 API 测试工具的强大功能。今天，我们来看看 Apifox 如何进一步提升效率，并对比它们的不同之处！  🤔 什么是 Apifox？Apifox &#x3D; Postman（接口测试） + Swagger（接口文档） + Mock（模拟数据） + JMeter（接口自动化测试） 是不是听着就很酷？它把接口相关的工作全都集成到了一起，避免了 Postman 只能测，Swagger 只能写文档的尴尬局面。 🔥 Apifox vs. Postman   特性 Apifox Postman    接口测试 ✅ ✅   接口文档 ✅ ❌   Mock...</div></div></div></a><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-07-28-logcat-guide-for-testers/" title="Logcat 日志详解与测试工程师实战指南"><img class="cover" src="/img/logcat-guide.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-28</div><div class="info-item-2">Logcat 日志详解与测试工程师实战指南</div></div><div class="info-2"><div class="info-item-1">Logcat 日志详解与测试工程师实战指南 适用人群：Android 测试工程师、开发工程师、自动化平台构建者、产品支持人员关键词：Logcat、日志等级、日志过滤、异常排查、自动化测试、日志分析   📌 一、Logcat 是什么？它记录了什么？Logcat 是 Android 提供的系统级日志收集与输出工具，其日志来源可以分为：    类型 示例 说明    应用日志 Log.d(&quot;Login&quot;, &quot;Token missing&quot;) 由开发者主动打的调试信息   系统日志 ActivityManager, WindowManager 系统服务相关日志   崩溃日志 FATAL EXCEPTION 应用在运行时的 Java&#x2F;Kotlin 崩溃堆栈   ANR 日志 ActivityManager: ANR in ... 应用无响应（UI线程被阻塞）事件   GC 回收日志 GC_CONCURRENT, GC_FOR_ALLOC 内存垃圾回收操作及耗时   电池&#x2F;网络&#x2F;传感器等 BatteryStats,...</div></div></div></a><a class="pagination-related" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%93%E7%B3%BB/2025-10-02-pytest-courses-comparison/" title="📚 pytest学习指南：白月黑羽vs码尚教育课程对比与学习策略"><img class="cover" src="/img/pytest.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-02</div><div class="info-item-2">📚 pytest学习指南：白月黑羽vs码尚教育课程对比与学习策略</div></div><div class="info-2"><div class="info-item-1">📚 pytest学习指南：白月黑羽vs码尚教育课程对比与学习策略👋 大家好！最近我连续学习了两门关于pytest自动化测试框架的课程：白月黑羽的pytest系列教程和码尚教育的pytest自动化测试框架课程。通过对比学习，我发现这两门课程各有特色和优势，如果能够结合学习，可以更全面、更深入地掌握pytest。今天我就来详细对比这两门课程，并分享如何高效结合学习的策略！ 📊 一、课程概览与对比🔍 课程基本信息   对比项 白月黑羽pytest课程 码尚教育pytest课程    课程类型 视频+图文教程 视频教程   内容时长 相对较长，内容全面 中等长度，侧重实战   课程链接 哔哩哔哩 哔哩哔哩   官网支持 提供配套练习环境和代码下载 主要通过B站视频学习   更新频率 定期更新，保持内容新鲜 根据Python版本更新   🎯 课程侧重点对比白月黑羽课程特点✅ 循序渐进：从最基础的概念开始，一步步引导学习者入门✅ 系统全面：涵盖从安装配置到高级功能的所有知识点✅ 实例丰富：提供大量贴近实际项目的案例✅ 配套资源：有详细的图文教程和配套练习题✅...</div></div></div></a><a class="pagination-related" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%93%E7%B3%BB/2025-10-01-pytest-automation-testing-guide/" title="🚀 Pytest自动化测试框架入门到实战：我的学习笔记与实战经验"><img class="cover" src="/img/pytest.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-01</div><div class="info-item-2">🚀 Pytest自动化测试框架入门到实战：我的学习笔记与实战经验</div></div><div class="info-2"><div class="info-item-1">🚀 Pytest自动化测试框架入门到实战：我的学习笔记与实战经验😊 大家好！最近我系统学习了pytest自动化测试框架！作为一名测试工程师，掌握一个高效的测试框架对提高工作效率至关重要。今天我就把这段时间的学习笔记和实战经验整理出来，希望能帮助到正在学习或准备学习自动化测试的朋友们！ 📚 本文基于白月黑羽编程的pytest自动化测试框架系列课程，强烈推荐给想系统学习的同学：  视频课程：pytest自动化测试框架 - 哔哩哔哩 图文教程：pytest框架 - 白月黑羽官网  🌟 一、为什么选择Pytest？在开始学习之前，我也对比了市面上几种主流的Python测试框架，最终选择pytest是因为它真的太香了！ ✅...</div></div></div></a><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3/2025-06-19-interface-documentation-guide/" title="🛡️ 测试开发不再背锅：一份可落地的接口文档避坑指南 🚧"><img class="cover" src="/img/interface-documentation-guide.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-19</div><div class="info-item-2">🛡️ 测试开发不再背锅：一份可落地的接口文档避坑指南 🚧</div></div><div class="info-2"><div class="info-item-1">🛡️ 测试开发不再背锅：一份可落地的接口文档避坑指南 🚧引言：从踩坑到真香的接口文档进化史作为一名在测试平台项目里摸爬滚打的测试开发工程师，我曾在凌晨 3 点对着黑屏电脑怒吼：「这接口返回的字段怎么又变了？！」💢 前端同事甩来的 bug 截图上，null 值像幽灵一样出现在不该出现的地方，而后端同学坚持「文档里写得清清楚楚」——直到我翻出三个月前的文档，才发现字段变更记录被淹没在聊天记录里😅。 而我也在不断迭代测试平台的过程中意识到，接口文档并不仅仅是给机器读的说明书，而是贯穿前端、后端、测试三方协作的重要资产。当我们将其从「应付差事」变为「团队共建的协作资产」后，文档准确率和可维护性显著提升，联调时间缩短一半，bug 率下降 30%，甚至新人 onboarding 时也不再手忙脚乱。 这篇文章就是我结合实战总结的一套接口文档避坑指南，希望对你有所启发。 一、接口文档的核心目标与原则（测试开发版）1. 核心目标：三大救命场景 💡 前端调用无歧义：前端将 createTime 当字符串传，后端却要求时间戳，文档里一句 “格式：13 位时间戳”...</div></div></div></a><a class="pagination-related" href="/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA/%E6%B5%8B%E8%AF%95%E7%9F%A5%E8%AF%86%E6%B2%89%E6%B7%80/2025-06-05-AI-heima/" title="🧠 探秘 AI + 软件测试：黑马程序员课程的奇妙之旅"><img class="cover" src="/img/AI-heima.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-05</div><div class="info-item-2">🧠 探秘 AI + 软件测试：黑马程序员课程的奇妙之旅</div></div><div class="info-2"><div class="info-item-1">🧠 探秘 AI + 软件测试：黑马程序员课程的奇妙之旅😎最近我在跟着黑马程序员的课程学习AI+软件测试，今天就先来和大家分享一下我在课程里学到的一些基础内容。 🔗 课程链接：AI+软件测试【黑马程序员】  🌟 一、AI 快速入门 推荐网站：黑马星云 AI 助理 推荐模型：百度文心大模型  🎯 AI 在软件测试中的作用：  提升测试速度与效率 支持缺陷预测与分析  🧩 指令 Prompt 组成：  角色（Role） 指示（Instruction） 可选：上下文、示例、输入、输出   🧪 二、测试基础（分类）📌 按生产阶段划分   测试类型 说明 类比    单元测试 对代码最小单元进行测试 检查每块砖 🧱   集成测试 测试模块间交互功能 组装房屋部件 🔗   系统测试 测试整个系统 整体房屋检查 🏠   验收测试 验证是否满足用户需求 业主验收 👀   📌 按代码可见度划分   测试类型 特点 类比    黑盒测试 代码不可见，仅测试输入输出 看房外观 🏡   灰盒测试 部分代码可见 知道部分结构 🧐   白盒测试 全部代码可见 清楚内部细节...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/ loading='lazy'></div><div class="author-info-name">yuxiaoling</div><div class="author-info-description">分享软件测试学习、实战经验和踩坑历程</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">83</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">314</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">19</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Linn0813"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Linn0813" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yuxiaoling.yxl@qq.com" target="_blank" title="Email"><i class="fa fa-envelope-open-text"></i></a><a class="social-icon" href="javascript:alert('微信公众号：Linn的技术笔记')" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://weibo.com/Linn0813" target="_blank" title="微博"><i class="fab fa-weibo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">下雨就不想上班</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%90-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">🌐 接口测试的简介与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%93-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">❓ 什么是接口测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%82-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">📂 接口测试分类：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%81-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">🔁 接口测试的流程与用例设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E7%86%9F%E6%82%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.0.1.</span> <span class="toc-text">1️⃣ 熟悉接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">2.0.2.</span> <span class="toc-text">2️⃣ 编写接口测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E6%89%A7%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95"><span class="toc-number">2.0.3.</span> <span class="toc-text">3️⃣ 执行接口测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><span class="toc-number">2.0.4.</span> <span class="toc-text">4️⃣ 持续集成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%B0-Postman-%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">🧰 Postman 简介与介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">界面说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">请求页面说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A1%B5%E7%AD%BE%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.</span> <span class="toc-text">响应页签说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Get%E8%AF%B7%E6%B1%82%E5%92%8CPost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">Get请求和Post请求的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">环境变量与全局变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%85%B3%E8%81%94"><span class="toc-number">6.</span> <span class="toc-text">接口关联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-number">6.0.1.</span> <span class="toc-text">JSON 提取器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-number">6.0.2.</span> <span class="toc-text">正则表达式提取器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9A%A1-%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">⚡ 动态参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E7%B1%BB-%E2%8F%B0"><span class="toc-number">7.0.1.</span> <span class="toc-text">1. 时间与日期类 ⏰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%B1%BB-%F0%9F%8E%B2"><span class="toc-number">7.0.2.</span> <span class="toc-text">2. 随机数据类 🎲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%B1%BB-%F0%9F%A7%AA"><span class="toc-number">7.0.3.</span> <span class="toc-text">3. 模拟数据类 🧪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">7.0.4.</span> <span class="toc-text">自定义动态参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%8A-Postman-%E6%96%AD%E8%A8%80"><span class="toc-number">8.</span> <span class="toc-text">📊 Postman 断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%85%AD%E7%A7%8D%E6%96%AD%E8%A8%80"><span class="toc-number">8.1.</span> <span class="toc-text">常规六种断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Status-code%EF%BC%9ACode-is-200%EF%BC%88%E7%8A%B6%E6%80%81%E7%A0%81%E6%96%AD%E8%A8%80%EF%BC%89%E2%9C%85"><span class="toc-number">8.1.1.</span> <span class="toc-text">1. Status code：Code is 200（状态码断言）✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Responsebody%EF%BC%9AContains-string%EF%BC%88%E5%93%8D%E5%BA%94%E4%BD%93%E5%8C%85%E5%90%AB%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%94%8D"><span class="toc-number">8.1.2.</span> <span class="toc-text">2. Responsebody：Contains string（响应体包含字符串断言）🔍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Responsebody%EF%BC%9AJson-value-check%EF%BC%88JSON-%E5%80%BC%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%A7%BE"><span class="toc-number">8.1.3.</span> <span class="toc-text">3. Responsebody：Json value check（JSON 值断言）🧾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Responsebody%EF%BC%9Ais-equal-to-a-string%EF%BC%88%E5%93%8D%E5%BA%94%E4%BD%93%E7%AD%89%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%93%8F"><span class="toc-number">8.1.4.</span> <span class="toc-text">4. Responsebody：is equal to a string（响应体等于字符串断言）📏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Response-headers%EF%BC%9AContent-Type%E2%80%A6%EF%BC%88%E5%93%8D%E5%BA%94%E5%A4%B4%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%93%8B"><span class="toc-number">8.1.5.</span> <span class="toc-text">5. Response headers：Content-Type…（响应头断言）📋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Response-time-is-less-than-200ms%EF%BC%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%96%AD%E8%A8%80%EF%BC%89%E2%8F%B1%EF%B8%8F"><span class="toc-number">8.1.6.</span> <span class="toc-text">6. Response time is less than 200ms（响应时间断言）⏱️</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%A7-%E5%9C%A8%E6%96%AD%E8%A8%80%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">🔧 在断言中获取自定义动态参数的方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%8D-%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80"><span class="toc-number">10.</span> <span class="toc-text">🌍 全局断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">10.1.</span> <span class="toc-text">实现全局断言的三种方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-1%EF%BC%9A%E5%9C%A8-Collection-%E4%B8%AD%E7%BC%96%E5%86%99%E5%85%AC%E5%85%B1%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="toc-number">10.1.1.</span> <span class="toc-text">方案 1：在 Collection 中编写公共测试脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BD%AE%E8%84%9A%E6%9C%AC%EF%BC%88Pre-request-Script%EF%BC%89%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5%E6%96%AD%E8%A8%80"><span class="toc-number">10.1.2.</span> <span class="toc-text">方案 2：使用前置脚本（Pre-request Script）动态注入断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-3%EF%BC%9A%E9%80%9A%E8%BF%87-Newman-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80"><span class="toc-number">10.1.3.</span> <span class="toc-text">方案 3：通过 Newman 命令行添加全局断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80%E4%B8%8E%E5%B1%80%E9%83%A8%E6%96%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%A7%E5%88%B6"><span class="toc-number">10.2.</span> <span class="toc-text">全局断言与局部断言的优先级控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%AA-Postman-%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">11.</span> <span class="toc-text">🧪 Postman 批量运行测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E5%92%8C%E7%BB%84%E7%BB%87%E7%94%A8%E4%BE%8B"><span class="toc-number">11.1.</span> <span class="toc-text">1. 创建集合和组织用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">11.1.1.</span> <span class="toc-text">2. 选择运行方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE-Runner-%E5%8F%82%E6%95%B0"><span class="toc-number">11.1.2.</span> <span class="toc-text">3. 配置 Runner 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">11.1.3.</span> <span class="toc-text">4. 执行批量测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E6%9E%90%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">11.1.4.</span> <span class="toc-text">5. 分析运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%82-Postman-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">12.</span> <span class="toc-text">📂 Postman 数据驱动测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-CSV-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">12.1.</span> <span class="toc-text">✅ CSV 参数化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%81-CSV-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82"><span class="toc-number">12.1.1.</span> <span class="toc-text">📁 CSV 文件格式要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A5-%E5%AF%BC%E5%85%A5-CSV-%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.1.2.</span> <span class="toc-text">📥 导入 CSV 步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%97-%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">12.1.3.</span> <span class="toc-text">🔗 请求中引用变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-JSON-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">12.2.</span> <span class="toc-text">✅ JSON 参数化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%81-JSON-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82"><span class="toc-number">12.2.1.</span> <span class="toc-text">📁 JSON 文件格式要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A5-%E5%AF%BC%E5%85%A5-JSON-%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.2.2.</span> <span class="toc-text">📥 导入 JSON 步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%97-%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.2.3.</span> <span class="toc-text">🔗 引用方式示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%BE-%E8%AF%B7%E6%B1%82%E5%BF%85%E9%A1%BB%E6%90%BA%E5%B8%A6%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AF%B4%E6%98%8E"><span class="toc-number">13.</span> <span class="toc-text">🧾 请求必须携带的请求头说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%A7-Postman%E6%8E%A5%E5%8F%A3Mock-Servier%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">🔧 Postman接口Mock Servier服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-Mock-Server-%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.1.</span> <span class="toc-text">🧪 Mock Server 核心价值与应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="toc-number">14.1.1.</span> <span class="toc-text">核心价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.1.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%88%9B%E5%BB%BA-Mock-Server-%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5%E7%94%A8%E6%88%B7%E7%A4%BA%E4%BE%8B%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">14.2.</span> <span class="toc-text">⚙️ 创建 Mock Server 全流程（以用户示例为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87-Mock-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="toc-number">14.2.1.</span> <span class="toc-text">1. 准备 Mock 响应数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8-Postman-%E4%B8%AD%E5%88%9B%E5%BB%BA-Mock-Server"><span class="toc-number">14.2.2.</span> <span class="toc-text">2. 在 Postman 中创建 Mock Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%8D%E7%AB%AF%E8%B0%83%E7%94%A8-Mock-%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B%EF%BC%88JavaScript%EF%BC%89"><span class="toc-number">14.2.3.</span> <span class="toc-text">3. 前端调用 Mock 接口示例（JavaScript）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8D%AA-Postman-%E7%9A%84-Cookie-%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6"><span class="toc-number">15.</span> <span class="toc-text">🍪 Postman 的 Cookie 鉴权机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Cookie-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">15.1.</span> <span class="toc-text">1. Cookie 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%89%B4%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="toc-number">15.2.</span> <span class="toc-text">2. 鉴权流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cookie-%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">15.2.1.</span> <span class="toc-text">3. Cookie 类型对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%90-Postman-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86"><span class="toc-number">16.</span> <span class="toc-text">🔐 Postman 实现接口加密与解密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">16.1.</span> <span class="toc-text">主流加密算法分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Postman-%E4%B8%AD%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">16.2.</span> <span class="toc-text">Postman 中加密实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE-CryptoJS%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">16.2.1.</span> <span class="toc-text">✅ 使用内置 CryptoJS（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-%E5%A4%96%E9%83%A8-JS-%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5"><span class="toc-number">16.2.2.</span> <span class="toc-text">🔄 外部 JS 文件导入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E8%A7%A3%E5%AF%86%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%EF%BC%88Tests-%E8%84%9A%E6%9C%AC%E4%B8%AD%EF%BC%89"><span class="toc-number">16.3.</span> <span class="toc-text">🔍 解密响应数据（Tests 脚本中）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Tests-%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%A7%A3%E5%AF%86%E5%93%8D%E5%BA%94"><span class="toc-number">16.3.1.</span> <span class="toc-text">在 Tests 脚本中解密响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C"><span class="toc-number">16.3.2.</span> <span class="toc-text">使用环境变量存储解密结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%90-%E5%8A%A0%E5%AF%86%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.4.</span> <span class="toc-text">🔐 加密场景示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9A%80-Newman"><span class="toc-number">17.</span> <span class="toc-text">🚀 Newman</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-Newman-%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">17.1.</span> <span class="toc-text">🚀 Newman 核心价值与应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9B%A0-Newman-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">17.2.</span> <span class="toc-text">🛠 Newman 安装与基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">17.2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84"><span class="toc-number">17.2.2.</span> <span class="toc-text">基础命令结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">17.2.3.</span> <span class="toc-text">核心参数说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8F%83%E2%80%8D%E2%99%82%EF%B8%8F-%E4%BB%8E-Postman-%E5%88%B0-Newman-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">17.3.</span> <span class="toc-text">🏃‍♂️ 从 Postman 到 Newman 的完整流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%BC%E5%87%BA-Collection-%E5%92%8C-Environment"><span class="toc-number">17.3.1.</span> <span class="toc-text">1. 导出 Collection 和 Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95"><span class="toc-number">17.3.2.</span> <span class="toc-text">2. 执行基本测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">17.3.3.</span> <span class="toc-text">3. 参数化测试示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">17.3.4.</span> <span class="toc-text">4. 并发与全局变量示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A4%96-Postman-Newman-Jenkins-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%88%98"><span class="toc-number">18.</span> <span class="toc-text">🤖 Postman + Newman + Jenkins 持续集成实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4%E9%80%9F%E8%A7%88"><span class="toc-number">18.1.</span> <span class="toc-text">核心步骤速览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%96%A5-%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">18.2.</span> <span class="toc-text">🖥 详细操作步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">18.2.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jenkins-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE"><span class="toc-number">18.2.2.</span> <span class="toc-text">Jenkins 项目配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E5%85%B3%E9%94%AE%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="toc-number">18.3.</span> <span class="toc-text">🔍 关键命令解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">18.4.</span> <span class="toc-text">⚠️ 常见问题及解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81"><span class="toc-number">18.5.</span> <span class="toc-text">✅ 执行效果验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">18.6.</span> <span class="toc-text">写在最后</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF/AI%E4%B8%8E%E7%A0%94%E7%A9%B6/2025-12-27-llm-agent-glossary/" title="📚 工具篇｜LLM/Agent 系列术语速查手册"><img src="/img/llm-agent-glossary.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="📚 工具篇｜LLM/Agent 系列术语速查手册"/ loading='lazy'></a><div class="content"><a class="title" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF/AI%E4%B8%8E%E7%A0%94%E7%A9%B6/2025-12-27-llm-agent-glossary/" title="📚 工具篇｜LLM/Agent 系列术语速查手册">📚 工具篇｜LLM/Agent 系列术语速查手册</a><time datetime="2025-12-27T12:00:00.000Z" title="发表于 2025-12-27 20:00:00">2025-12-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%81%8C%E4%B8%9A%E6%88%90%E9%95%BF%E4%B8%8E%E6%80%9D%E8%80%83/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/2025-12-26-resume-tech-buzzwords-guide/" title="📝 简历里的&quot;高级感&quot;从哪来？互联网与技术黑话大拆解"><img src="/img/resume-guide.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="📝 简历里的&quot;高级感&quot;从哪来？互联网与技术黑话大拆解"/ loading='lazy'></a><div class="content"><a class="title" href="/%E8%81%8C%E4%B8%9A%E6%88%90%E9%95%BF%E4%B8%8E%E6%80%9D%E8%80%83/%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF/2025-12-26-resume-tech-buzzwords-guide/" title="📝 简历里的&quot;高级感&quot;从哪来？互联网与技术黑话大拆解">📝 简历里的&quot;高级感&quot;从哪来？互联网与技术黑话大拆解</a><time datetime="2025-12-26T12:00:00.000Z" title="发表于 2025-12-26 20:00:00">2025-12-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-12-25-fiddler-to-charles-migration-guide/" title="从 Fiddler 到 Charles：Windows 切换到 Mac 的抓包实践分享 🍎"><img src="/img/fiddler-to-charles.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="从 Fiddler 到 Charles：Windows 切换到 Mac 的抓包实践分享 🍎"/ loading='lazy'></a><div class="content"><a class="title" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0/2025-12-25-fiddler-to-charles-migration-guide/" title="从 Fiddler 到 Charles：Windows 切换到 Mac 的抓包实践分享 🍎">从 Fiddler 到 Charles：Windows 切换到 Mac 的抓包实践分享 🍎</a><time datetime="2025-12-25T10:00:00.000Z" title="发表于 2025-12-25 18:00:00">2025-12-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF/AI%E4%B8%8E%E7%A0%94%E7%A9%B6/2025-12-24-llm-agent-evaluation/" title="📊 主题15｜Agent 评估：指标体系与避坑指南"><img src="/img/llm-agent-evaluation.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="📊 主题15｜Agent 评估：指标体系与避坑指南"/ loading='lazy'></a><div class="content"><a class="title" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF/AI%E4%B8%8E%E7%A0%94%E7%A9%B6/2025-12-24-llm-agent-evaluation/" title="📊 主题15｜Agent 评估：指标体系与避坑指南">📊 主题15｜Agent 评估：指标体系与避坑指南</a><time datetime="2025-12-24T10:00:00.000Z" title="发表于 2025-12-24 18:00:00">2025-12-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF/AI%E4%B8%8E%E7%A0%94%E7%A9%B6/2025-12-23-llm-agent-multi-agent-collaboration/" title="👥 主题14｜多 Agent 协作：像团队一样工作的一群智能体"><img src="/img/llm-agent-multi-agent-collaboration.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="👥 主题14｜多 Agent 协作：像团队一样工作的一群智能体"/ loading='lazy'></a><div class="content"><a class="title" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF/AI%E4%B8%8E%E7%A0%94%E7%A9%B6/2025-12-23-llm-agent-multi-agent-collaboration/" title="👥 主题14｜多 Agent 协作：像团队一样工作的一群智能体">👥 主题14｜多 Agent 协作：像团队一样工作的一群智能体</a><time datetime="2025-12-23T10:00:00.000Z" title="发表于 2025-12-23 18:00:00">2025-12-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By yuxiaoling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'Linn0813/Linn0813.github.io',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script src="/js/blog-enhancements.js"></script><script src="/js/category-enhancements.js"></script><script src="/js/series-enhancements.js"></script><script src="/js/post-series-meta.js"></script><script src="/js/archive-enhancements.js"></script><script src="/js/tag-enhancements.js"></script><script src="/js/index-enhancements.js"></script><script src="/js/sidebar-series-card.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>