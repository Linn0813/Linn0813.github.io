<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>从入门到实战：一篇文章掌握接口测试与 Postman 全流程 | Linn's Blog</title><meta name="author" content="yuxiaoling"><meta name="copyright" content="yuxiaoling"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="分享码尚教育Postman课程的学习内容，详细介绍接口测试的概念、分类、流程与用例设计，全面讲解 Postman 的使用方法，包括界面操作、断言设置、数据驱动测试和 Mock Server 等功能，适合接口测试初学者与自动化测试入门者学习。">
<meta property="og:type" content="article">
<meta property="og:title" content="从入门到实战：一篇文章掌握接口测试与 Postman 全流程">
<meta property="og:url" content="https://linn0813.github.io/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/%E6%B5%8B%E8%AF%95%E7%90%86%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95-Testing-Concepts-Methods/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-Testing-Methods/2025-06-20-postman-class/index.html">
<meta property="og:site_name" content="Linn&#39;s Blog">
<meta property="og:description" content="分享码尚教育Postman课程的学习内容，详细介绍接口测试的概念、分类、流程与用例设计，全面讲解 Postman 的使用方法，包括界面操作、断言设置、数据驱动测试和 Mock Server 等功能，适合接口测试初学者与自动化测试入门者学习。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://linn0813.github.io/img/postman-class.png">
<meta property="article:published_time" content="2025-06-20T02:09:35.000Z">
<meta property="article:modified_time" content="2025-10-27T12:51:30.926Z">
<meta property="article:author" content="yuxiaoling">
<meta property="article:tag" content="自动化测试">
<meta property="article:tag" content="Postman">
<meta property="article:tag" content="软件测试">
<meta property="article:tag" content="接口测试">
<meta property="article:tag" content="测试用例">
<meta property="article:tag" content="Newman">
<meta property="article:tag" content="Mock Server">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://linn0813.github.io/img/postman-class.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "从入门到实战：一篇文章掌握接口测试与 Postman 全流程",
  "url": "https://linn0813.github.io/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/%E6%B5%8B%E8%AF%95%E7%90%86%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95-Testing-Concepts-Methods/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-Testing-Methods/2025-06-20-postman-class/",
  "image": "https://linn0813.github.io/img/postman-class.png",
  "datePublished": "2025-06-20T02:09:35.000Z",
  "dateModified": "2025-10-27T12:51:30.926Z",
  "author": [
    {
      "@type": "Person",
      "name": "yuxiaoling",
      "url": "https://linn0813.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://linn0813.github.io/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/%E6%B5%8B%E8%AF%95%E7%90%86%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95-Testing-Concepts-Methods/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-Testing-Methods/2025-06-20-postman-class/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '从入门到实战：一篇文章掌握接口测试与 Postman 全流程',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/ loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">217</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url(/img/postman-class.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/logo.jpg" alt="Logo" loading='lazy'><span class="site-name">Linn's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">从入门到实战：一篇文章掌握接口测试与 Postman 全流程</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">从入门到实战：一篇文章掌握接口测试与 Postman 全流程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-20T02:09:35.000Z" title="发表于 2025-06-20 10:09:35">2025-06-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-27T12:51:30.926Z" title="更新于 2025-10-27 20:51:30">2025-10-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/">测试基础与理论 / Testing Fundamentals</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/%E6%B5%8B%E8%AF%95%E7%90%86%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95-Testing-Concepts-Methods/">测试理念与方法 / Testing Concepts &amp; Methods</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/%E6%B5%8B%E8%AF%95%E7%90%86%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95-Testing-Concepts-Methods/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-Testing-Methods/">测试方法 / Testing Methods</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">6.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;天自上次更新，文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-10-27 20:51:30&quot;}" hidden></div><blockquote>
<p>🚀 这是我在 B 站课程《接口测试的简介与分类》（<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV11K4y1J7sh?vd_source=65c2968c09490f4b218154711916b4d8">点击直达</a>）学习过程中的详细笔记与实操总结，面向接口测试初学者与自动化测试入门者，希望对你有所启发。</p>
</blockquote>
<hr>
<h1 id="🌐-接口测试的简介与分类"><a href="#🌐-接口测试的简介与分类" class="headerlink" title="🌐 接口测试的简介与分类"></a>🌐 接口测试的简介与分类</h1><h2 id="❓-什么是接口测试？"><a href="#❓-什么是接口测试？" class="headerlink" title="❓ 什么是接口测试？"></a>❓ 什么是接口测试？</h2><p>接口测试是指对系统组件之间的数据传递、业务逻辑接口等内容进行测试，验证各模块间是否能正确交互与协作。🔁</p>
<h2 id="📂-接口测试分类："><a href="#📂-接口测试分类：" class="headerlink" title="📂 接口测试分类："></a>📂 接口测试分类：</h2><ul>
<li><p><strong>外部接口测试</strong><br>系统对接外部第三方服务，如支付接口、物流接口，主要验证正向功能。<br>○ 只需验证正例（接口是否返回成功）✅</p>
</li>
<li><p><strong>内部接口测试</strong><br>○ ① 内部调用接口：模块之间对接使用，如预算系统与承保系统。<br>■ 只需验证正例<br>○ ② 开放给外部的内部接口：业务核心接口，如 App 端调用后端接口。<br>■ 需验证正例 + 异常 + 权限 + 安全性</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>典型场景</th>
<th>测试重点</th>
<th>扩展测试点</th>
</tr>
</thead>
<tbody><tr>
<td>外部接口</td>
<td>第三方支付、物流查询</td>
<td>正向流程（如支付下单 - 回调通知）</td>
<td>网络异常（断网、超时）、限流处理</td>
</tr>
<tr>
<td>内部接口</td>
<td>电商系统“库存扣减”与“订单创建”对接</td>
<td>数据一致性（库存扣减失败时订单回滚）</td>
<td>并发调用（多用户同时下单锁机制）</td>
</tr>
<tr>
<td>开放内部接口</td>
<td>App 端用户登录接口</td>
<td>权限校验、SQL 注入防护</td>
<td>敏感数据加密（密码传输加密）🔒</td>
</tr>
</tbody></table>
<hr>
<h1 id="🔁-接口测试的流程与用例设计"><a href="#🔁-接口测试的流程与用例设计" class="headerlink" title="🔁 接口测试的流程与用例设计"></a>🔁 接口测试的流程与用例设计</h1><h3 id="1️⃣-熟悉接口"><a href="#1️⃣-熟悉接口" class="headerlink" title="1️⃣ 熟悉接口"></a>1️⃣ 熟悉接口</h3><ul>
<li><p>获取方式：<br>○ 查看接口文档<br>○ 抓包工具（如 Charles&#x2F;Fiddler）观察请求</p>
</li>
<li><p>熟悉内容：<br>○ 接口地址、请求方式（GET&#x2F;POST等）<br>○ 鉴权机制（Token&#x2F;Cookie）<br>○ 请求参数与响应结构<br>○ 状态码及错误码定义</p>
</li>
</ul>
<hr>
<h3 id="2️⃣-编写接口测试用例"><a href="#2️⃣-编写接口测试用例" class="headerlink" title="2️⃣ 编写接口测试用例"></a>2️⃣ 编写接口测试用例</h3><ul>
<li><p>用例设计思路：</p>
<ul>
<li><p>正例：<br>○ 合理入参 + 正确鉴权 → 返回成功结果</p>
</li>
<li><p>反例：<br>○ 鉴权类：Token 缺失、错误、过期<br>○ 参数类：参数为空、格式错误、类型&#x2F;长度不符<br>○ 业务类：错误码验证、边界值、分页逻辑<br>○ 安全类：黑名单用户、访问频率限制、权限验证</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3️⃣-执行接口测试"><a href="#3️⃣-执行接口测试" class="headerlink" title="3️⃣ 执行接口测试"></a>3️⃣ 执行接口测试</h3><ul>
<li>使用 Postman 编写请求，管理集合和环境变量</li>
<li>手动调试，确认功能逻辑正确</li>
</ul>
<hr>
<h3 id="4️⃣-持续集成"><a href="#4️⃣-持续集成" class="headerlink" title="4️⃣ 持续集成"></a>4️⃣ 持续集成</h3><ul>
<li>使用 Newman 执行 Postman 脚本</li>
<li>将测试集成至 Jenkins 流水线，输出测试报告，并通过邮件&#x2F;钉钉同步结果 📩</li>
</ul>
<hr>
<h1 id="🧰-Postman-简介与介绍"><a href="#🧰-Postman-简介与介绍" class="headerlink" title="🧰 Postman 简介与介绍"></a>🧰 Postman 简介与介绍</h1><h2 id="界面说明"><a href="#界面说明" class="headerlink" title="界面说明"></a>界面说明</h2><ul>
<li>Home：主页</li>
<li>Workspaces：工作空间管理</li>
<li>Collections：接口集合管理</li>
<li>APIs：API 文档管理</li>
<li>Environments：环境变量与全局变量</li>
<li>Mock Server：虚拟服务器</li>
<li>Monitors：定时监控器</li>
<li>History：历史请求记录</li>
</ul>
<hr>
<h2 id="请求页面说明"><a href="#请求页面说明" class="headerlink" title="请求页面说明"></a>请求页面说明</h2><ul>
<li><p>Params：GET 请求参数</p>
</li>
<li><p>Authorization：设置 Token、Basic Auth 等鉴权方式</p>
</li>
<li><p>Headers：请求头（如 Content-Type、Cookie 等）</p>
</li>
<li><p>Body（POST 请求参数）：</p>
<ul>
<li>none：不传参数</li>
<li>form-data：支持键值对和文件</li>
<li>x-www-form-urlencoded：表单键值对</li>
<li>raw：json、text、xml、html、JavaScript、text等原始格式</li>
<li>binary：文件上传（二进制）</li>
</ul>
</li>
<li><p>pre-request script：请求前执行 JS 脚本</p>
</li>
<li><p>tests：请求后执行断言</p>
</li>
<li><p>cookies：管理 Cookie 信息</p>
</li>
</ul>
<hr>
<h2 id="响应页签说明"><a href="#响应页签说明" class="headerlink" title="响应页签说明"></a>响应页签说明</h2><ul>
<li><p>Body：返回内容</p>
</li>
<li><p>Pretty：以 Json、html、XML 等格式查看数据</p>
</li>
<li><p>Raw：文本方式查看数据</p>
</li>
<li><p>Preview：网页方式查看数据</p>
</li>
<li><p>Cookies：响应中返回的 Cookie</p>
</li>
<li><p>Headers：响应头</p>
</li>
<li><p>Test Results：断言执行结果</p>
</li>
<li><p>状态码与响应信息：</p>
<ul>
<li>200：OK</li>
<li>响应时间（如 681ms）</li>
<li>响应大小（如 343B）</li>
</ul>
</li>
</ul>
<hr>
<h1 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h1><h2 id="Get请求和Post请求的区别"><a href="#Get请求和Post请求的区别" class="headerlink" title="Get请求和Post请求的区别"></a>Get请求和Post请求的区别</h2><ol>
<li>get 请求一般是获取数据，post 请求一般是提交数据。</li>
<li>post 请求比 get 请求更安全。</li>
<li>本质区别是传参方式不同：</li>
</ol>
<ul>
<li>get 请求在地址栏后面以 ? 方式传参，多个参数用 &amp; 分隔。</li>
<li>post 请求在 body 以表单方式传参。</li>
</ul>
<hr>
<h1 id="环境变量与全局变量"><a href="#环境变量与全局变量" class="headerlink" title="环境变量与全局变量"></a>环境变量与全局变量</h1><ul>
<li>环境变量：限定于特定环境（如 dev&#x2F;test&#x2F;prod），variable 命名必须一致，接口地址中使用 。</li>
<li>全局变量：所有环境、所有接口共享，跨接口共享数据（如登录 Token、用户 ID）。</li>
<li>获取环境变量和全局变量的值通过 。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>作用域</th>
<th>典型用途</th>
<th>优先级（冲突时）</th>
</tr>
</thead>
<tbody><tr>
<td>环境变量</td>
<td>限定于特定环境</td>
<td>不同环境的配置差异（API 域名、端口）</td>
<td>高于全局变量</td>
</tr>
<tr>
<td>全局变量</td>
<td>所有环境共享</td>
<td>跨接口共享数据</td>
<td>低于环境变量</td>
</tr>
</tbody></table>
<hr>
<h1 id="接口关联"><a href="#接口关联" class="headerlink" title="接口关联"></a>接口关联</h1><h3 id="JSON-提取器"><a href="#JSON-提取器" class="headerlink" title="JSON 提取器"></a>JSON 提取器</h3><p>第一个接口:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用json提取器提取accesss_token值。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把返回的字符串格式的数据转换成对象的形式。</span></span><br><span class="line"><span class="keyword">var</span> result = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(responseBody);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把access_token设置为全局变量</span></span><br><span class="line">pm.<span class="property">globals</span>.<span class="title function_">set</span>(<span class="string">&quot;access_token&quot;</span>,result.<span class="property">access_tokern</span>);</span><br></pre></td></tr></table></figure>

<p>第二个接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;access_token&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="正则表达式提取器"><a href="#正则表达式提取器" class="headerlink" title="正则表达式提取器"></a>正则表达式提取器</h3><p>第一个接口:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用正则表达式提取器实现接口关联,match匹配。</span></span><br><span class="line"><span class="keyword">var</span> result = responseBody.<span class="title function_">match</span>(<span class="keyword">new</span> <span class="title class_">RegExp</span>(<span class="string">&#x27;&quot;access_token&quot;:&quot;(.*?)&quot;&#x27;</span>)) </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result[<span class="number">1</span>]);</span><br><span class="line"><span class="comment">//设置为全局变量</span></span><br><span class="line">pm.<span class="property">globals</span>.<span class="title function_">set</span>(<span class="string">&quot;access_token&quot;</span>,result[<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>第二个接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;access_token&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="⚡-动态参数"><a href="#⚡-动态参数" class="headerlink" title="⚡ 动态参数"></a>⚡ 动态参数</h1><p>Postman 内置动态参数：</p>
<h3 id="1-时间与日期类-⏰"><a href="#1-时间与日期类-⏰" class="headerlink" title="1. 时间与日期类 ⏰"></a>1. 时间与日期类 ⏰</h3><table>
<thead>
<tr>
<th>参数</th>
<th>格式示例</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>1689345678（秒级）</td>
<td>生成当前时间戳（如签名计算）</td>
</tr>
<tr>
<td></td>
<td>2025-06-18T12:34:56Z</td>
<td>随机日期（测试订单有效期）</td>
</tr>
<tr>
<td></td>
<td>2025-06-18T12:34:56.789Z</td>
<td>符合 ISO 8601 格式的时间戳</td>
</tr>
</tbody></table>
<p><strong>使用方法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 pre-request script 中组合参数</span></span><br><span class="line">pm.<span class="property">environment</span>.<span class="title function_">set</span>(<span class="string">&quot;orderId&quot;</span>, <span class="string">&quot;ORD_&quot;</span> + <span class="title class_">Date</span>.<span class="title function_">now</span>());</span><br><span class="line"><span class="comment">// 请求 URL 中使用：https://api.com/order/&#123;&#123;orderId&#125;&#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="2-随机数据类-🎲"><a href="#2-随机数据类-🎲" class="headerlink" title="2. 随机数据类 🎲"></a>2. 随机数据类 🎲</h3><table>
<thead>
<tr>
<th>参数</th>
<th>格式示例</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>345（0-1000 内随机数）</td>
<td>测试分页大小（如 size&#x3D;）</td>
</tr>
<tr>
<td></td>
<td>abcdef12345（16 位随机字符串）</td>
<td>生成随机用户名</td>
</tr>
<tr>
<td></td>
<td>5f7d3a9c-1b2e-4c3d-8e9f-0a1b2c3d4e5f</td>
<td>唯一标识符（测试分布式 ID）</td>
</tr>
</tbody></table>
<hr>
<h3 id="3-模拟数据类-🧪"><a href="#3-模拟数据类-🧪" class="headerlink" title="3. 模拟数据类 🧪"></a>3. 模拟数据类 🧪</h3><table>
<thead>
<tr>
<th>参数</th>
<th>格式示例</th>
<th>典型用途</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><a href="mailto:&#x75;&#115;&#x65;&#114;&#53;&#x36;&#x37;&#x40;&#101;&#x78;&#97;&#x6d;&#112;&#108;&#x65;&#46;&#x63;&#111;&#109;">user567@example.com</a></td>
<td>注册测试（随机邮箱）</td>
</tr>
<tr>
<td></td>
<td>+1 (555) 123-4567</td>
<td>测试短信验证码接口</td>
</tr>
<tr>
<td></td>
<td>4111 1111 1111 1111</td>
<td>支付模拟（需配合 Mock Server）</td>
</tr>
</tbody></table>
<hr>
<h3 id="自定义动态参数"><a href="#自定义动态参数" class="headerlink" title="自定义动态参数"></a>自定义动态参数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手动获得时间戳</span></span><br><span class="line"><span class="keyword">var</span> times = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line"><span class="comment">// 设置为全局变量</span></span><br><span class="line">pm.<span class="property">globals</span>.<span class="title function_">set</span>(<span class="string">&quot;times&quot;</span>, times);</span><br></pre></td></tr></table></figure>

<p><strong>使用时调用：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#123;times&#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="📊-Postman-断言"><a href="#📊-Postman-断言" class="headerlink" title="📊 Postman 断言"></a>📊 Postman 断言</h1><h2 id="常规六种断言"><a href="#常规六种断言" class="headerlink" title="常规六种断言"></a>常规六种断言</h2><h3 id="1-Status-code：Code-is-200（状态码断言）✅"><a href="#1-Status-code：Code-is-200（状态码断言）✅" class="headerlink" title="1. Status code：Code is 200（状态码断言）✅"></a>1. Status code：Code is 200（状态码断言）✅</h3><p><strong>作用：</strong> 验证接口返回的 HTTP 状态码是否符合预期（如 200、404 等）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;状态码应为 200&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>扩展场景：</strong></p>
<ul>
<li>验证客户端错误（4xx）：<code>pm.response.to.have.status(401)</code>（未授权）；</li>
<li>验证服务器错误（5xx）：<code>pm.response.to.have.status(500)</code>（内部错误）。</li>
</ul>
<hr>
<h3 id="2-Responsebody：Contains-string（响应体包含字符串断言）🔍"><a href="#2-Responsebody：Contains-string（响应体包含字符串断言）🔍" class="headerlink" title="2. Responsebody：Contains string（响应体包含字符串断言）🔍"></a>2. Responsebody：Contains string（响应体包含字符串断言）🔍</h3><p><strong>作用：</strong> 检查响应内容是否包含指定字符串（支持文本、JSON、XML 等格式）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应体包含 success&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>()).<span class="property">to</span>.<span class="title function_">include</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>若响应为 JSON，需先通过 <code>pm.response.json()</code> 解析；</li>
<li>区分大小写（如 “Success” 与 “success” 不同），可通过 <code>to.include(&quot;success&quot;, &#123;ignoreCase: true&#125;)</code> 忽略大小写。</li>
</ul>
<hr>
<h3 id="3-Responsebody：Json-value-check（JSON-值断言）🧾"><a href="#3-Responsebody：Json-value-check（JSON-值断言）🧾" class="headerlink" title="3. Responsebody：Json value check（JSON 值断言）🧾"></a>3. Responsebody：Json value check（JSON 值断言）🧾</h3><p><strong>作用：</strong> 验证响应 JSON 中特定字段的值是否符合预期。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;用户 ID 应为 123&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> responseJson = pm.<span class="property">response</span>.<span class="title function_">json</span>();</span><br><span class="line">    pm.<span class="title function_">expect</span>(responseJson.<span class="property">user</span>.<span class="property">id</span>).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="number">123</span>);  <span class="comment">// 严格等于</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>多层嵌套场景：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 响应结构：&#123; &quot;data&quot;: &#123; &quot;list&quot;: [&#123;&quot;id&quot;: &quot;ORD001&quot;&#125;] &#125; &#125;</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;第一个订单 ID 正确&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = pm.<span class="property">response</span>.<span class="title function_">json</span>().<span class="property">data</span>.<span class="property">list</span>[<span class="number">0</span>].<span class="property">id</span>;</span><br><span class="line">    pm.<span class="title function_">expect</span>(id).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="string">&quot;ORD001&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-Responsebody：is-equal-to-a-string（响应体等于字符串断言）📏"><a href="#4-Responsebody：is-equal-to-a-string（响应体等于字符串断言）📏" class="headerlink" title="4. Responsebody：is equal to a string（响应体等于字符串断言）📏"></a>4. Responsebody：is equal to a string（响应体等于字符串断言）📏</h3><p><strong>作用：</strong> 验证响应内容与指定字符串完全一致（较少使用，因响应常含动态数据）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应体等于指定字符串&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>()).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="string">&#x27;&#123;&quot;status&quot;: &quot;ok&quot;&#125;&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>优化建议：</strong></p>
<ul>
<li>避免直接断言完整响应体，可拆分字段断言；</li>
<li>对动态字段（如时间戳）使用通配符或正则表达式（需结合 Chai 库）。</li>
</ul>
<hr>
<h3 id="5-Response-headers：Content-Type…（响应头断言）📋"><a href="#5-Response-headers：Content-Type…（响应头断言）📋" class="headerlink" title="5. Response headers：Content-Type…（响应头断言）📋"></a>5. Response headers：Content-Type…（响应头断言）📋</h3><p><strong>作用：</strong> 检查响应头是否包含指定字段（如 Content-Type、Authorization）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 断言存在 Content-Type 头</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应头包含 Content-Type&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言 Content-Type 为 JSON 格式</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;Content-Type 应为 application/json&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="6-Response-time-is-less-than-200ms（响应时间断言）⏱️"><a href="#6-Response-time-is-less-than-200ms（响应时间断言）⏱️" class="headerlink" title="6. Response time is less than 200ms（响应时间断言）⏱️"></a>6. Response time is less than 200ms（响应时间断言）⏱️</h3><p><strong>作用：</strong> 验证接口响应时间是否小于指定毫秒数（用于性能初步测试）。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应时间应小于 200ms&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="property">responseTime</span>).<span class="property">to</span>.<span class="property">be</span>.<span class="title function_">below</span>(<span class="number">200</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>扩展用法：</strong></p>
<ul>
<li>断言响应时间在区间内：<code>pm.expect(responseTime).to.be.within(100, 300)</code>；</li>
<li>结合环境变量动态设置阈值：<code>pm.expect(responseTime).to.be.below(pm.environment.get(&quot;maxResponseTime&quot;))</code>。</li>
</ul>
<hr>
<h1 id="🔧-在断言中获取自定义动态参数的方式"><a href="#🔧-在断言中获取自定义动态参数的方式" class="headerlink" title="🔧 在断言中获取自定义动态参数的方式"></a>🔧 在断言中获取自定义动态参数的方式</h1><table>
<thead>
<tr>
<th>获取方式</th>
<th>语法示例</th>
<th>适用场景</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>pm.globals.get(“参数名”)</td>
<td>pm.globals.get(“times”)</td>
<td>推荐通用写法，兼容性强</td>
<td>需通过 pm 上下文调用，适用于 Pre-request Script、Tests 脚本</td>
</tr>
<tr>
<td>globals[“参数名”]</td>
<td>globals[“times”]</td>
<td>键名动态拼接场景</td>
<td>旧版本 Postman 可能不支持</td>
</tr>
<tr>
<td>globals.参数名</td>
<td>globals.times</td>
<td>键名无特殊字符时简写</td>
<td>参数名含特殊字符需用方括号访问</td>
</tr>
</tbody></table>
<hr>
<h1 id="🌍-全局断言"><a href="#🌍-全局断言" class="headerlink" title="🌍 全局断言"></a>🌍 全局断言</h1><h2 id="实现全局断言的三种方案"><a href="#实现全局断言的三种方案" class="headerlink" title="实现全局断言的三种方案"></a>实现全局断言的三种方案</h2><h3 id="方案-1：在-Collection-中编写公共测试脚本"><a href="#方案-1：在-Collection-中编写公共测试脚本" class="headerlink" title="方案 1：在 Collection 中编写公共测试脚本"></a>方案 1：在 Collection 中编写公共测试脚本</h3><p><strong>原理：</strong> 在 Collection 的 Tests 标签页中编写断言，对集合内所有接口生效。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;全局状态码校验&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">be</span>.<span class="property">success</span>;  <span class="comment">// 断言状态码为2xx</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;全局响应头校验&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">header</span>(<span class="string">&quot;Content-Type&quot;</span>);</span><br><span class="line">    pm.<span class="title function_">expect</span>(pm.<span class="property">response</span>.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;Content-Type&quot;</span>)).<span class="property">to</span>.<span class="title function_">include</span>(<span class="string">&quot;json&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>集合级断言优先级低于单个接口断言；</li>
<li>可用 <code>pm.info.requestName</code> 判断接口名，实现条件断言：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pm.<span class="property">info</span>.<span class="property">requestName</span> !== <span class="string">&quot;健康检查接口&quot;</span>) &#123;</span><br><span class="line">    pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(<span class="number">200</span>);  <span class="comment">// 排除特定接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方案-2：使用前置脚本（Pre-request-Script）动态注入断言"><a href="#方案-2：使用前置脚本（Pre-request-Script）动态注入断言" class="headerlink" title="方案 2：使用前置脚本（Pre-request Script）动态注入断言"></a>方案 2：使用前置脚本（Pre-request Script）动态注入断言</h3><p><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 Collection 或 Folder 的 Pre-request Script 中添加</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addGlobalAssertion</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 动态生成断言代码字符串</span></span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">        pm.test(&quot;全局响应时间校验&quot;, function() &#123;</span></span><br><span class="line"><span class="string">            pm.expect(pm.response.responseTime).to.be.below(<span class="subst">$&#123;pm.environment.get(<span class="string">&quot;maxResponseTime&quot;</span>) || <span class="number">1000</span>&#125;</span>);</span></span><br><span class="line"><span class="string">        &#125;);</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">    <span class="comment">// 将断言代码注入到当前请求的 Tests 中</span></span><br><span class="line">    pm.<span class="title function_">test</span>(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件执行（如仅在非本地环境执行）</span></span><br><span class="line"><span class="keyword">if</span> (pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;envType&quot;</span>) !== <span class="string">&quot;local&quot;</span>) &#123;</span><br><span class="line">    <span class="title function_">addGlobalAssertion</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="方案-3：通过-Newman-命令行添加全局断言"><a href="#方案-3：通过-Newman-命令行添加全局断言" class="headerlink" title="方案 3：通过 Newman 命令行添加全局断言"></a>方案 3：通过 Newman 命令行添加全局断言</h3><p><strong>原理：</strong> Newman 运行时通过脚本参数注入全局断言。<br><strong>示例代码：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// newman-run.js 脚本内容</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Collection</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;postman-collection&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="attr">beforeRun</span>: <span class="function">(<span class="params">collection</span>) =&gt;</span> &#123;</span><br><span class="line">        collection.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.<span class="property">request</span>) &#123;</span><br><span class="line">                item.<span class="property">test</span> = <span class="keyword">new</span> <span class="title class_">Collection</span>.<span class="title class_">ItemTest</span>(&#123;</span><br><span class="line">                    <span class="attr">script</span>: &#123;</span><br><span class="line">                        <span class="attr">exec</span>: [</span><br><span class="line">                            <span class="string">&quot;pm.test(\&quot;全局状态码校验\&quot;, function() &#123;&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;    pm.response.to.be.success;&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;&#125;);&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;pm.test(\&quot;全局响应头校验\&quot;, function() &#123;&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;    pm.response.to.have.header(\&quot;X-Request-ID\&quot;);&quot;</span>,</span><br><span class="line">                            <span class="string">&quot;&#125;);&quot;</span></span><br><span class="line">                        ].<span class="title function_">join</span>(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>执行命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">newman run collection.json --script newman-run.js</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="全局断言与局部断言的优先级控制"><a href="#全局断言与局部断言的优先级控制" class="headerlink" title="全局断言与局部断言的优先级控制"></a>全局断言与局部断言的优先级控制</h2><table>
<thead>
<tr>
<th>断言位置</th>
<th>优先级</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>单个接口的 Tests</td>
<td>最高</td>
<td>针对特定接口的特殊验证</td>
</tr>
<tr>
<td>Folder 级 Tests</td>
<td>中</td>
<td>分组接口的公共验证</td>
</tr>
<tr>
<td>Collection 级 Tests</td>
<td>最低</td>
<td>全量接口的基础验证（状态码、响应头）</td>
</tr>
</tbody></table>
<p><strong>冲突解决方案：</strong><br>接口级 Tests 中使用 <code>pm.test.remove()</code> 移除不需要的全局断言：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除集合中的全局响应时间断言</span></span><br><span class="line">pm.<span class="property">test</span>.<span class="title function_">remove</span>(<span class="string">&quot;全局响应时间校验&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🧪-Postman-批量运行测试用例"><a href="#🧪-Postman-批量运行测试用例" class="headerlink" title="🧪 Postman 批量运行测试用例"></a>🧪 Postman 批量运行测试用例</h1><p>在 Postman 中批量运行测试用例，主要通过 Collection Runner 功能来实现，以下是具体步骤：</p>
<h2 id="1-创建集合和组织用例"><a href="#1-创建集合和组织用例" class="headerlink" title="1. 创建集合和组织用例"></a>1. 创建集合和组织用例</h2><ul>
<li>点击左侧 “Collections” 的 “➕” 按钮创建集合，输入集合名称。</li>
<li>选中集合点击 “⋯” → <strong>Add Folder</strong> 添加模块文件夹。</li>
<li>再选中文件夹点击 <strong>Add Request</strong> 添加接口测试用例，配置请求参数、断言脚本，将接口组织到集合中。</li>
</ul>
<h3 id="2-选择运行方式"><a href="#2-选择运行方式" class="headerlink" title="2. 选择运行方式"></a>2. 选择运行方式</h3><ul>
<li>✅ 点击集合右上角 <strong>Run</strong>：全模块回归测试。</li>
<li>✅ 点击文件夹右上角 <strong>Run folder</strong>：单模块迭代测试。</li>
</ul>
<h3 id="3-配置-Runner-参数"><a href="#3-配置-Runner-参数" class="headerlink" title="3. 配置 Runner 参数"></a>3. 配置 Runner 参数</h3><ul>
<li><p><strong>Iterations</strong>：设置测试迭代次数。</p>
</li>
<li><p><strong>Delay</strong>：设置接口调用间隔（单位：ms）。</p>
</li>
<li><p><strong>Data</strong>：导入 CSV &#x2F; JSON 文件进行参数化。</p>
</li>
<li><p><strong>Advanced settings</strong>：</p>
<ul>
<li>✅ 勾选 “Persist responses” 保存响应。</li>
<li>🔁 选择 “Run order” 控制执行顺序（按文件夹顺序或随机执行）。</li>
</ul>
</li>
</ul>
<h3 id="4-执行批量测试"><a href="#4-执行批量测试" class="headerlink" title="4. 执行批量测试"></a>4. 执行批量测试</h3><p>点击 <strong>Run</strong> 或 <strong>Run 文件夹名称</strong> 按钮，即可批量运行测试用例。</p>
<h3 id="5-分析运行结果"><a href="#5-分析运行结果" class="headerlink" title="5. 分析运行结果"></a>5. 分析运行结果</h3><ul>
<li>📊 汇总信息：运行时间、迭代次数、通过&#x2F;失败数量、平均响应时间等。</li>
<li>🔍 单接口详情：状态码、响应时间、响应体、断言结果、错误信息。</li>
</ul>
<hr>
<h1 id="📂-Postman-数据驱动测试"><a href="#📂-Postman-数据驱动测试" class="headerlink" title="📂 Postman 数据驱动测试"></a>📂 Postman 数据驱动测试</h1><h2 id="✅-CSV-参数化测试"><a href="#✅-CSV-参数化测试" class="headerlink" title="✅ CSV 参数化测试"></a>✅ CSV 参数化测试</h2><h3 id="📁-CSV-文件格式要求"><a href="#📁-CSV-文件格式要求" class="headerlink" title="📁 CSV 文件格式要求"></a>📁 CSV 文件格式要求</h3><ul>
<li>第一行为表头，后续行为数据。</li>
<li>使用英文逗号 <code>,</code> 分隔，若字段含逗号，需用双引号包裹。</li>
</ul>
<p>示例文件 <code>users.csv</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">username,password,expected_status</span><br><span class="line">admin,admin123,200</span><br><span class="line">guest,guest456,200</span><br><span class="line">invalid_user,wrong_pwd,401</span><br></pre></td></tr></table></figure>

<h3 id="📥-导入-CSV-步骤"><a href="#📥-导入-CSV-步骤" class="headerlink" title="📥 导入 CSV 步骤"></a>📥 导入 CSV 步骤</h3><ol>
<li>Runner 中选择集合或文件夹 → 点击 <strong>Select File</strong>。</li>
<li>选择 CSV 文件 → Postman 自动识别变量名并预览数据。</li>
</ol>
<h3 id="🔗-请求中引用变量"><a href="#🔗-请求中引用变量" class="headerlink" title="🔗 请求中引用变量"></a>🔗 请求中引用变量</h3><ul>
<li><p>URL 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.com/login?username=&#123;&#123;username&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>请求体参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#123;username&#125;&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&#123;&#123;password&#125;&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>在断言中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;状态码校验&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  pm.<span class="property">response</span>.<span class="property">to</span>.<span class="property">have</span>.<span class="title function_">status</span>(pm.<span class="property">iterationData</span>.<span class="title function_">get</span>(<span class="string">&quot;expected_status&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="✅-JSON-参数化测试"><a href="#✅-JSON-参数化测试" class="headerlink" title="✅ JSON 参数化测试"></a>✅ JSON 参数化测试</h2><h3 id="📁-JSON-文件格式要求"><a href="#📁-JSON-文件格式要求" class="headerlink" title="📁 JSON 文件格式要求"></a>📁 JSON 文件格式要求</h3><ul>
<li>根节点为数组，每组对象为一组测试数据。</li>
</ul>
<p>示例 <code>orders.json</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;productId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;P001&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">99.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expectedTotal&quot;</span><span class="punctuation">:</span> <span class="number">99.9</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;productId&quot;</span><span class="punctuation">:</span> <span class="string">&quot;P002&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;price&quot;</span><span class="punctuation">:</span> <span class="number">49.9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;expectedTotal&quot;</span><span class="punctuation">:</span> <span class="number">149.7</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="📥-导入-JSON-步骤"><a href="#📥-导入-JSON-步骤" class="headerlink" title="📥 导入 JSON 步骤"></a>📥 导入 JSON 步骤</h3><ul>
<li>同样在 Runner 中选择 JSON 文件，Postman 自动识别变量。</li>
</ul>
<h3 id="🔗-引用方式示例"><a href="#🔗-引用方式示例" class="headerlink" title="🔗 引用方式示例"></a>🔗 引用方式示例</h3><ul>
<li><p>URL 参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://api.com/order/&#123;&#123;productId&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>请求体参数：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;quantity&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span>quantity<span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;unitPrice&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="punctuation">&#123;</span>price<span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
<li><p>JSON 断言：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;金额计算正确&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> response = pm.<span class="property">response</span>.<span class="title function_">json</span>();</span><br><span class="line">  pm.<span class="title function_">expect</span>(response.<span class="property">total</span>).<span class="property">to</span>.<span class="title function_">eql</span>(pm.<span class="property">iterationData</span>.<span class="title function_">get</span>(<span class="string">&quot;expectedTotal&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="🧾-请求必须携带的请求头说明"><a href="#🧾-请求必须携带的请求头说明" class="headerlink" title="🧾 请求必须携带的请求头说明"></a>🧾 请求必须携带的请求头说明</h1><table>
<thead>
<tr>
<th>请求头名</th>
<th>说明</th>
<th>示例值</th>
</tr>
</thead>
<tbody><tr>
<td>Host</td>
<td>指定目标主机（HTTP&#x2F;1.1要求）</td>
<td><code>api.example.com</code></td>
</tr>
<tr>
<td>Connection</td>
<td>是否保持长连接</td>
<td><code>keep-alive</code></td>
</tr>
<tr>
<td>Accept</td>
<td>可接受的响应格式</td>
<td><code>application/json</code></td>
</tr>
<tr>
<td>X-Requested-With</td>
<td>是否为 AJAX 请求</td>
<td><code>XMLHttpRequest</code></td>
</tr>
<tr>
<td>User-Agent</td>
<td>客户端身份标识</td>
<td><code>Mozilla/5.0...</code></td>
</tr>
<tr>
<td>Referer</td>
<td>请求来源页面 URL</td>
<td><code>https://example.com</code></td>
</tr>
<tr>
<td>Cookie</td>
<td>携带的 Cookie 信息</td>
<td><code>session_id=123456; user_token=abc</code></td>
</tr>
<tr>
<td>Content-Type</td>
<td>请求体的格式类型</td>
<td><code>application/json</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="🔧-Postman接口Mock-Servier服务器"><a href="#🔧-Postman接口Mock-Servier服务器" class="headerlink" title="🔧 Postman接口Mock Servier服务器"></a>🔧 Postman接口Mock Servier服务器</h1><h2 id="🧪-Mock-Server-核心价值与应用场景"><a href="#🧪-Mock-Server-核心价值与应用场景" class="headerlink" title="🧪 Mock Server 核心价值与应用场景"></a>🧪 Mock Server 核心价值与应用场景</h2><h3 id="核心价值"><a href="#核心价值" class="headerlink" title="核心价值"></a>核心价值</h3><p>解决痛点：后端接口尚未开发完成时，前端可通过 Mock Server 模拟接口响应，实现并行开发，提升开发效率。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul>
<li>前后端分离开发，后端进度滞后时前端可独立调试</li>
<li>测试复杂业务流程（如支付回调、状态变更）</li>
<li>模拟异常情况（如网络超时、服务器错误）</li>
</ul>
<hr>
<h2 id="⚙️-创建-Mock-Server-全流程（以用户示例为例）"><a href="#⚙️-创建-Mock-Server-全流程（以用户示例为例）" class="headerlink" title="⚙️ 创建 Mock Server 全流程（以用户示例为例）"></a>⚙️ 创建 Mock Server 全流程（以用户示例为例）</h2><h3 id="1-准备-Mock-响应数据"><a href="#1-准备-Mock-响应数据" class="headerlink" title="1. 准备 Mock 响应数据"></a>1. 准备 Mock 响应数据</h3><p>示例 JSON（注意逗号格式）：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error_code&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;msg&quot;</span><span class="punctuation">:</span> <span class="string">&quot;返回成功&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;data&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-在-Postman-中创建-Mock-Server"><a href="#2-在-Postman-中创建-Mock-Server" class="headerlink" title="2. 在 Postman 中创建 Mock Server"></a>2. 在 Postman 中创建 Mock Server</h3><p><strong>步骤如下：</strong></p>
<ol>
<li><p>创建 Collection：</p>
<ul>
<li>点击左侧 Collections → ➕ → 命名为“前端 Mock 接口”</li>
<li>添加请求（如 GET&#x2F;POST）→ 命名为“获取数据接口”</li>
</ul>
</li>
<li><p>配置请求与响应：</p>
<ul>
<li>请求 URL 可自定义，如：<code>https://mock-api.com/data/query</code></li>
<li>切换至 Response 标签页 → 选择 <code>raw</code> → 粘贴 JSON</li>
<li>设置状态码为 <code>200 OK</code></li>
</ul>
</li>
<li><p>生成 Mock Server：</p>
<ul>
<li>点击 Collection 的 <code>…</code> → 选择 <code>Generate Mock Server</code></li>
<li>设置域名（如：<code>mock-server.postman.com</code>）</li>
<li>点击 Create Mock → 复制生成的 Mock URL，如：<br><code>https://postman-echo.com/mock/12345/data/query</code></li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-前端调用-Mock-接口示例（JavaScript）"><a href="#3-前端调用-Mock-接口示例（JavaScript）" class="headerlink" title="3. 前端调用 Mock 接口示例（JavaScript）"></a>3. 前端调用 Mock 接口示例（JavaScript）</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://postman-echo.com/mock/12345/data/query&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;application/json&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">response</span> =&gt;</span> response.<span class="title function_">json</span>())</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;接口返回:&quot;</span>, data);</span><br><span class="line">  <span class="comment">// 渲染或处理数据</span></span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;请求错误:&quot;</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🍪-Postman-的-Cookie-鉴权机制"><a href="#🍪-Postman-的-Cookie-鉴权机制" class="headerlink" title="🍪 Postman 的 Cookie 鉴权机制"></a>🍪 Postman 的 Cookie 鉴权机制</h1><h2 id="1-Cookie-是什么"><a href="#1-Cookie-是什么" class="headerlink" title="1. Cookie 是什么"></a>1. Cookie 是什么</h2><ul>
<li>由服务器生成的小段 <code>key=value</code> 格式文本</li>
<li>存储在浏览器或 Postman 中，用于身份验证、会话控制等</li>
</ul>
<h2 id="2-鉴权流程"><a href="#2-鉴权流程" class="headerlink" title="2. 鉴权流程"></a>2. 鉴权流程</h2><ol>
<li>当客户端第一次访问服务器的时候,那么服务器就会生成Cookie信息,并且在响应头的set-cookie里面把生成的cookie信息发送给客户端。</li>
<li>当客户端第2-N次访问服务器的时候,那么客户端就会在请求头的cookie带上cookie信息,从而实现鉴权</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">首次请求 → 服务器生成 Set-Cookie 响应头 → 客户端保存 Cookie</span><br><span class="line">↓</span><br><span class="line">后续请求 → 客户端自动附带 Cookie 请求头 → 服务器完成身份校验</span><br></pre></td></tr></table></figure>

<h3 id="3-Cookie-类型对比"><a href="#3-Cookie-类型对比" class="headerlink" title="3. Cookie 类型对比"></a>3. Cookie 类型对比</h3><table>
<thead>
<tr>
<th>类型</th>
<th>存储位置</th>
<th>生命周期</th>
<th>安全性</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>会话 Cookie</td>
<td>内存</td>
<td>浏览器关闭即失效</td>
<td>较低</td>
<td>购物车、临时登录</td>
</tr>
<tr>
<td>持久 Cookie</td>
<td>硬盘</td>
<td>设定的过期时间前有效</td>
<td>较高</td>
<td>记住我、长期登录</td>
</tr>
</tbody></table>
<hr>
<h1 id="🔐-Postman-实现接口加密与解密"><a href="#🔐-Postman-实现接口加密与解密" class="headerlink" title="🔐 Postman 实现接口加密与解密"></a>🔐 Postman 实现接口加密与解密</h1><h2 id="主流加密算法分类"><a href="#主流加密算法分类" class="headerlink" title="主流加密算法分类"></a>主流加密算法分类</h2><table>
<thead>
<tr>
<th>类型</th>
<th>代表算法</th>
<th>特点</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>对称加密</td>
<td>AES &#x2F; DES &#x2F; Base64</td>
<td>加解密使用同一密钥，速度快</td>
<td>请求体数据加密</td>
</tr>
<tr>
<td>非对称加密</td>
<td>RSA &#x2F; ECC</td>
<td>公钥加密私钥解密，较安全</td>
<td>数字签名、密钥交换</td>
</tr>
<tr>
<td>单向哈希</td>
<td>MD5 &#x2F; SHA256</td>
<td>不可逆，用于验证完整性</td>
<td>密码存储、数据签名</td>
</tr>
</tbody></table>
<hr>
<h2 id="Postman-中加密实现方式"><a href="#Postman-中加密实现方式" class="headerlink" title="Postman 中加密实现方式"></a>Postman 中加密实现方式</h2><h3 id="✅-使用内置-CryptoJS（推荐）"><a href="#✅-使用内置-CryptoJS（推荐）" class="headerlink" title="✅ 使用内置 CryptoJS（推荐）"></a>✅ 使用内置 CryptoJS（推荐）</h3><p>Postman 内置了 Crypto-js 库，支持 AES、MD5、SHA 等多种加密算法。</p>
<p><strong>AES 加密请求体：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Pre-request Script中添加</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待加密数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(&#123;</span><br><span class="line">    <span class="string">&quot;username&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">    <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123456&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密钥（需与后端保持一致）</span></span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&quot;1234567890123456&quot;</span>; <span class="comment">// 16字节密钥（AES-128）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AES加密（ECB模式 + PKCS7填充）</span></span><br><span class="line"><span class="keyword">const</span> encrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(data, secretKey, &#123;</span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">ECB</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">&#125;).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置加密后的数据到请求体</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">body</span>.<span class="property">raw</span> = encrypted;</span><br></pre></td></tr></table></figure>

<p><strong>MD5 签名：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Pre-request Script中添加</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待签名数据</span></span><br><span class="line"><span class="keyword">const</span> signData = <span class="string">&quot;param1=value1&amp;param2=value2&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&quot;your-api-secret&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成MD5签名</span></span><br><span class="line"><span class="keyword">const</span> signature = <span class="title class_">CryptoJS</span>.<span class="title class_">MD5</span>(signData + secretKey).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加签名到请求头</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">headers</span>.<span class="title function_">upsert</span>(&#123;</span><br><span class="line">    <span class="attr">key</span>: <span class="string">&quot;X-Signature&quot;</span>,</span><br><span class="line">    <span class="attr">value</span>: signature</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="🔄-外部-JS-文件导入"><a href="#🔄-外部-JS-文件导入" class="headerlink" title="🔄 外部 JS 文件导入"></a>🔄 外部 JS 文件导入</h3><p><strong>encrypt.js 文件：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">aesEncrypt</span>(<span class="params">data, key</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(data, key).<span class="title function_">toString</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用方式：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(pm.<span class="property">globals</span>.<span class="title function_">get</span>(<span class="string">&quot;encryptScript&quot;</span>)); <span class="comment">// 从全局变量获取脚本内容</span></span><br><span class="line"><span class="keyword">const</span> encrypted = <span class="title function_">aesEncrypt</span>(<span class="string">&quot;敏感数据&quot;</span>, <span class="string">&quot;密钥&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔍-解密响应数据（Tests-脚本中）"><a href="#🔍-解密响应数据（Tests-脚本中）" class="headerlink" title="🔍 解密响应数据（Tests 脚本中）"></a>🔍 解密响应数据（Tests 脚本中）</h2><h3 id="在-Tests-脚本中解密响应"><a href="#在-Tests-脚本中解密响应" class="headerlink" title="在 Tests 脚本中解密响应"></a>在 Tests 脚本中解密响应</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Tests脚本中添加</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从响应获取加密数据</span></span><br><span class="line"><span class="keyword">const</span> encryptedData = pm.<span class="property">response</span>.<span class="title function_">text</span>();</span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&quot;1234567890123456&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AES解密</span></span><br><span class="line"><span class="keyword">const</span> bytes = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(encryptedData, secretKey);</span><br><span class="line"><span class="keyword">const</span> decryptedData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(bytes.<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言解密后的数据</span></span><br><span class="line">pm.<span class="title function_">expect</span>(decryptedData.<span class="property">code</span>).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="number">0</span>);</span><br><span class="line">pm.<span class="title function_">expect</span>(decryptedData.<span class="property">data</span>.<span class="property">username</span>).<span class="property">to</span>.<span class="title function_">eql</span>(<span class="string">&quot;test&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="使用环境变量存储解密结果"><a href="#使用环境变量存储解密结果" class="headerlink" title="使用环境变量存储解密结果"></a>使用环境变量存储解密结果</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 解密后存储到环境变量供后续请求使用</span></span><br><span class="line">pm.<span class="property">environment</span>.<span class="title function_">set</span>(<span class="string">&quot;decryptedData&quot;</span>, decryptedData);</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔐-加密场景示例"><a href="#🔐-加密场景示例" class="headerlink" title="🔐 加密场景示例"></a>🔐 加密场景示例</h2><p><strong>RSA 加密（使用公钥）：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在Pre-request Script中添加（需先导入jsrsasign库）</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">JSEncrypt</span> = <span class="built_in">require</span>(<span class="string">&#x27;jsencrypt&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 公钥（从环境变量获取）</span></span><br><span class="line"><span class="keyword">const</span> publicKey = pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;rsaPublicKey&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 待加密数据</span></span><br><span class="line"><span class="keyword">const</span> data = <span class="string">&quot;敏感信息&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">const</span> encrypt = <span class="keyword">new</span> <span class="title class_">JSEncrypt</span>();</span><br><span class="line">encrypt.<span class="title function_">setPublicKey</span>(publicKey);</span><br><span class="line"><span class="keyword">const</span> encrypted = encrypt.<span class="title function_">encrypt</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置到请求体</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">body</span>.<span class="property">raw</span> = encrypted;</span><br></pre></td></tr></table></figure>

<p><strong>带时间戳的签名验证：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Pre-request Script</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CryptoJS</span> = <span class="built_in">require</span>(<span class="string">&#x27;crypto-js&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> timestamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成签名</span></span><br><span class="line"><span class="keyword">const</span> signData = <span class="string">`timestamp=<span class="subst">$&#123;timestamp&#125;</span>&amp;api_key=your_key`</span>;</span><br><span class="line"><span class="keyword">const</span> signature = <span class="title class_">CryptoJS</span>.<span class="title class_">SHA256</span>(signData + pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;apiSecret&quot;</span>)).<span class="title function_">toString</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到请求头</span></span><br><span class="line">pm.<span class="property">request</span>.<span class="property">headers</span>.<span class="title function_">upsert</span>(&#123; <span class="attr">key</span>: <span class="string">&quot;X-Timestamp&quot;</span>, <span class="attr">value</span>: timestamp &#125;);</span><br><span class="line">pm.<span class="property">request</span>.<span class="property">headers</span>.<span class="title function_">upsert</span>(&#123; <span class="attr">key</span>: <span class="string">&quot;X-Signature&quot;</span>, <span class="attr">value</span>: signature &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tests脚本验证响应签名</span></span><br><span class="line">pm.<span class="title function_">test</span>(<span class="string">&quot;响应签名验证&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> responseSign = pm.<span class="property">response</span>.<span class="property">headers</span>.<span class="title function_">get</span>(<span class="string">&quot;X-Response-Sign&quot;</span>);</span><br><span class="line">    <span class="keyword">const</span> expectedSign = <span class="title class_">CryptoJS</span>.<span class="title class_">SHA256</span>(pm.<span class="property">response</span>.<span class="title function_">text</span>() + pm.<span class="property">environment</span>.<span class="title function_">get</span>(<span class="string">&quot;apiSecret&quot;</span>)).<span class="title function_">toString</span>();</span><br><span class="line">    pm.<span class="title function_">expect</span>(responseSign).<span class="property">to</span>.<span class="title function_">eql</span>(expectedSign);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<hr>
<p>好的，以下是针对你提供的 <strong>Newman</strong> 相关内容的整理，带有适当表情提示，保持简洁且易读：</p>
<hr>
<h1 id="🚀-Newman"><a href="#🚀-Newman" class="headerlink" title="🚀 Newman"></a>🚀 Newman</h1><h2 id="🚀-Newman-核心价值与应用场景"><a href="#🚀-Newman-核心价值与应用场景" class="headerlink" title="🚀 Newman 核心价值与应用场景"></a>🚀 Newman 核心价值与应用场景</h2><p><strong>定位</strong>：Postman 的命令行运行器，适合自动化执行测试脚本，完美适配 CI&#x2F;CD 流水线。</p>
<p><strong>核心优势</strong>：</p>
<ul>
<li>🖥️ 脱离 GUI，可集成 Jenkins、GitLab CI 等自动化工具</li>
<li>🔄 支持批量运行、参数化测试、生成标准化报告</li>
<li>🌍 跨平台（Linux&#x2F;Windows&#x2F;Mac），支持团队协作</li>
</ul>
<hr>
<h2 id="🛠-Newman-安装与基础使用"><a href="#🛠-Newman-安装与基础使用" class="headerlink" title="🛠 Newman 安装与基础使用"></a>🛠 Newman 安装与基础使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g newman</span><br></pre></td></tr></table></figure>

<p>（需先安装 Node.js）</p>
<h3 id="基础命令结构"><a href="#基础命令结构" class="headerlink" title="基础命令结构"></a>基础命令结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newman run [collection文件路径] [选项参数]</span><br></pre></td></tr></table></figure>

<h3 id="核心参数说明"><a href="#核心参数说明" class="headerlink" title="核心参数说明"></a>核心参数说明</h3><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-e</code></td>
<td>指定环境变量文件 (JSON)</td>
<td><code>-e environments/test.json</code></td>
</tr>
<tr>
<td><code>-g</code></td>
<td>指定全局变量文件 (JSON)</td>
<td><code>-g globals/prod.json</code></td>
</tr>
<tr>
<td><code>-d</code></td>
<td>参数化测试数据文件 (CSV&#x2F;JSON)</td>
<td><code>-d data/users.csv</code></td>
</tr>
<tr>
<td><code>-n</code></td>
<td>迭代次数</td>
<td><code>-n 5</code> （每个用例执行 5 次）</td>
</tr>
<tr>
<td><code>-r</code></td>
<td>报告格式（支持多种组合）</td>
<td><code>-r cli,html,json,junit</code></td>
</tr>
<tr>
<td><code>--reporter-*</code></td>
<td>定制报告输出（如HTML路径）</td>
<td><code>--reporter-html-export reports/result.html</code></td>
</tr>
<tr>
<td><code>--delay-request</code></td>
<td>请求间隔（毫秒）</td>
<td><code>--delay-request 500</code></td>
</tr>
<tr>
<td><code>--insecure</code></td>
<td>允许忽略 HTTPS 证书验证</td>
<td><code>--insecure</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="🏃‍♂️-从-Postman-到-Newman-的完整流程"><a href="#🏃‍♂️-从-Postman-到-Newman-的完整流程" class="headerlink" title="🏃‍♂️ 从 Postman 到 Newman 的完整流程"></a>🏃‍♂️ 从 Postman 到 Newman 的完整流程</h2><h3 id="1-导出-Collection-和-Environment"><a href="#1-导出-Collection-和-Environment" class="headerlink" title="1. 导出 Collection 和 Environment"></a>1. 导出 Collection 和 Environment</h3><ul>
<li>Postman → 选择集合 → 点击 <code>...</code> → Export → 保存为 <code>collection.json</code></li>
<li>选择环境 → 点击 <code>...</code> → Export → 保存为 <code>environment.json</code></li>
</ul>
<h3 id="2-执行基本测试"><a href="#2-执行基本测试" class="headerlink" title="2. 执行基本测试"></a>2. 执行基本测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行集合，使用测试环境变量</span></span><br><span class="line">newman run collection.json -e environment.json</span><br></pre></td></tr></table></figure>

<h3 id="3-参数化测试示例"><a href="#3-参数化测试示例" class="headerlink" title="3. 参数化测试示例"></a>3. 参数化测试示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用CSV数据文件进行参数化测试，生成HTML报告</span></span><br><span class="line">newman run collection.json -e test.env.json -d data/users.csv -n 3 -r html --reporter-html-export reports/test-result.html</span><br></pre></td></tr></table></figure>

<h3 id="4-并发与全局变量示例"><a href="#4-并发与全局变量示例" class="headerlink" title="4. 并发与全局变量示例"></a>4. 并发与全局变量示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟10个并发用户，执行5次迭代，输出JUnit格式报告</span></span><br><span class="line">newman run collection.json -g globals.json -n 5 --concurrency 10 -r junit --reporter-junit-export reports/junit.xml</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🤖-Postman-Newman-Jenkins-持续集成实战"><a href="#🤖-Postman-Newman-Jenkins-持续集成实战" class="headerlink" title="🤖 Postman + Newman + Jenkins 持续集成实战"></a>🤖 Postman + Newman + Jenkins 持续集成实战</h1><h2 id="核心步骤速览"><a href="#核心步骤速览" class="headerlink" title="核心步骤速览"></a>核心步骤速览</h2><ol>
<li><p>环境准备</p>
<ul>
<li>安装 Jenkins（推荐 Docker 部署）</li>
<li>安装 Node.js 和 Newman（Jenkins 节点）</li>
<li>导出 Postman Collection 和环境变量文件</li>
</ul>
</li>
<li><p>Jenkins 配置</p>
<ul>
<li>新建自由风格项目</li>
<li>配置 Git 源码管理</li>
<li>添加构建步骤，执行 Newman 命令</li>
</ul>
</li>
<li><p>报告集成</p>
<ul>
<li>安装 HTML Publisher 插件</li>
<li>配置报告路径</li>
<li>保存并触发构建</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🖥-详细操作步骤"><a href="#🖥-详细操作步骤" class="headerlink" title="🖥 详细操作步骤"></a>🖥 详细操作步骤</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Docker安装 Jenkins（推荐）</span></span><br><span class="line">docker run -d -p 8080:8080 -v jenkins_home:/var/jenkins_home jenkins/jenkins:lts</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Jenkins节点安装 Newman</span></span><br><span class="line">npm install -g newman newman-reporter-html</span><br></pre></td></tr></table></figure>

<ul>
<li>导出 Postman Collection（<code>collection.json</code>）与环境变量文件（<code>environment.json</code>）</li>
</ul>
<hr>
<h3 id="Jenkins-项目配置"><a href="#Jenkins-项目配置" class="headerlink" title="Jenkins 项目配置"></a>Jenkins 项目配置</h3><ol>
<li><p>新建项目</p>
<ul>
<li>点击 New Item → 输入项目名 → 选择 Freestyle project</li>
</ul>
</li>
<li><p>源码管理</p>
<ul>
<li>选择 Git → 输入仓库地址 → 配置认证信息</li>
</ul>
</li>
<li><p>构建步骤</p>
<ul>
<li>添加 Execute shell（Linux&#x2F;macOS）：</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newman run collection.json \</span><br><span class="line">  -e environment.json \</span><br><span class="line">  -r html \</span><br><span class="line">  --reporter-html-export reports/index.html</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>构建后操作</p>
<ul>
<li><p>添加 Publish HTML reports 插件配置</p>
<ul>
<li>Report name: API测试报告</li>
<li>Directory: reports</li>
<li>Index page: index.html</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🔍-关键命令解析"><a href="#🔍-关键命令解析" class="headerlink" title="🔍 关键命令解析"></a>🔍 关键命令解析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">newman run collection.json \</span><br><span class="line">  -e environment.json \          <span class="comment"># 环境变量</span></span><br><span class="line">  -d data.csv \                  <span class="comment"># 参数化测试数据（可选）</span></span><br><span class="line">  -n 5 \                        <span class="comment"># 迭代次数（可选）</span></span><br><span class="line">  -r html \                     <span class="comment"># 生成HTML报告</span></span><br><span class="line">  --reporter-html-export reports/index.html  <span class="comment"># 报告路径</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚠️-常见问题及解决方案"><a href="#⚠️-常见问题及解决方案" class="headerlink" title="⚠️ 常见问题及解决方案"></a>⚠️ 常见问题及解决方案</h2><table>
<thead>
<tr>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody><tr>
<td>Newman 未找到</td>
<td>检查 Node.js 与 Newman 是否安装，或使用绝对路径（如 <code>/usr/bin/newman</code>）</td>
</tr>
<tr>
<td>报告为空</td>
<td>确认命令中的报告路径与 Jenkins 配置一致，确认 Newman 执行成功</td>
</tr>
<tr>
<td>中文乱码</td>
<td>添加参数 <code>--reporter-html-encoding utf-8</code></td>
</tr>
<tr>
<td>环境变量不生效</td>
<td>确保 <code>environment.json</code> 格式正确，变量名与 Postman 一致</td>
</tr>
</tbody></table>
<hr>
<h2 id="✅-执行效果验证"><a href="#✅-执行效果验证" class="headerlink" title="✅ 执行效果验证"></a>✅ 执行效果验证</h2><ol>
<li>触发 Jenkins 构建</li>
<li>构建成功后，点击左侧菜单中的 “API测试报告”</li>
<li>查看测试结果（成功率、响应时间、失败用例）</li>
</ol>
<hr>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过本次系统性学习，我对接口测试从原理、流程、工具到自动化的整个链路有了清晰的认识，Postman 不仅适合手动调试，还可以搭配 Newman 实现完整的自动化方案，未来在项目中我也会持续将这些方法应用于实践中。</p>
<p>如果你刚入门接口测试，希望这份整理对你有所帮助，也欢迎交流、讨论更多实战经验 🙌。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://Linn0813.github.io">yuxiaoling</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://linn0813.github.io/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/%E6%B5%8B%E8%AF%95%E7%90%86%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95-Testing-Concepts-Methods/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-Testing-Methods/2025-06-20-postman-class/">https://linn0813.github.io/%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E4%B8%8E%E7%90%86%E8%AE%BA-Testing-Fundamentals/%E6%B5%8B%E8%AF%95%E7%90%86%E5%BF%B5%E4%B8%8E%E6%96%B9%E6%B3%95-Testing-Concepts-Methods/%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-Testing-Methods/2025-06-20-postman-class/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">版权所有，转载请注明出处。</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/">自动化测试</a><a class="post-meta__tags" href="/tags/Postman/">Postman</a><a class="post-meta__tags" href="/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/">软件测试</a><a class="post-meta__tags" href="/tags/%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95/">接口测试</a><a class="post-meta__tags" href="/tags/%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B/">测试用例</a><a class="post-meta__tags" href="/tags/Newman/">Newman</a><a class="post-meta__tags" href="/tags/Mock-Server/">Mock Server</a></div><div class="post-share"><div class="social-share" data-image="/img/postman-class.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C-Testing-Practices-Case-Studies/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3-Issues-Solutions/Bug%E7%AE%A1%E7%90%86-Bug-Management/2025-06-19-bug-reporting-guide/" title="已测试工程师视角：如何优雅提 Bug，让开发主动修复？😎"><img class="cover" src="/img/bug-reporting-guide.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">已测试工程师视角：如何优雅提 Bug，让开发主动修复？😎</div></div><div class="info-2"><div class="info-item-1">已测试工程师视角：如何优雅提 Bug，让开发主动修复？😎 作为上一篇博文《🌟 Bug 责任端快速定位实战指南：从传统方法到 AI 辅助》的进一步分享，本文聚焦测试工程师如何高效、优雅地提 Bug，提升开发响应速度和修复意愿。作为一名测试岗位的一员，我曾因 Bug 描述不清被开发质疑“复现不了”，也曾因沟通不到位陷入协作瓶颈。但通过总结和实践，我找到了一套按端拆解的提 Bug 实战技巧，帮助我大幅提升 Bug 修复效率。   一、清晰、准确地描述 Bug 🚀Bug 描述是提 Bug 的核心，不同负责端的 Bug 在描述时有各自的重点，务必做到简洁明了、逻辑清晰。 （一）前端 Bug 详细复现步骤：按操作顺序列出，精确到每个交互动作和时间间隔。例如：  打开网页，等待页面完全加载； 点击顶部导航栏「用户中心」按钮，快速连续点击 3 次； 观察到页面出现白屏，无法显示用户信息。   明确环境信息：除常规系统、浏览器信息，还要标注屏幕分辨率、缩放比例等。例如：「Windows 11 系统，Chrome 115 浏览器，分辨率 1920×1080，页面缩放...</div></div></div></a><a class="pagination-related" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%B7%A5%E5%85%B7-Learning-Tools/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-Development-Tools/2025-06-23-cursor-hack/" title="🎉 超全！Cursor Pro 白嫖指南 😎"><img class="cover" src="/img/cursor-hack.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">🎉 超全！Cursor Pro 白嫖指南 😎</div></div><div class="info-2"><div class="info-item-1">🎉 超全！Cursor Pro 白嫖指南 😎🧠 Cursor 软件：功能简介与优势 🚀Cursor 是一款基于 VS Code 内核的 AI 编程助手，通过深度整合大语言模型（如 OpenAI GPT 系列），为开发者提供从代码补全、重构到调试建议的一站式智能支持。它不仅能根据自然语言指令生成代码片段，还能在复杂项目中理解上下文，帮助你快速定位和修复问题。 ✨ 核心优势一览 ✨  自然语言驱动 🗣️你可以用一句“请帮我添加一个排序算法”，Cursor 会自动生成对应代码，无需手动查文档。 上下文感知超长片段 📚支持超过 10k 字的项目上下文扫描，尤其在大型微服务或多文件协同项目里，智能补全更准确。 实时调试对话 🐞💬在 IDE 中直接发起调试会话，Cursor 能分析错误栈、给出修复建议，还能生成单元测试骨架。 丰富插件生态 🧩兼容所有 VS Code 插件，从主题、Lint，到 Docker，一套工具搞定所有开发场景。 多语言多框架支持 🌐开箱即用 Python、JavaScript、TypeScript、Go、Java、C++ 等主流语言，以及...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C-Testing-Practices-Case-Studies/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0-Testing-Experience/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8-Test-Tool-Application/2025-05-18-postman/" title="📨 Postman 使用指南 —— 测试工程师的快乐源泉"><img class="cover" src="/img/postman.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-18</div><div class="info-item-2">📨 Postman 使用指南 —— 测试工程师的快乐源泉</div></div><div class="info-2"><div class="info-item-1">📨 Postman 使用指南 —— 测试工程师的快乐源泉🎉 前言作为一名测试工程师，我们的日常离不开 Postman。它不仅是接口测试的神器，还是 Debug 的利器，甚至能拯救你的加班生活！ 如果你还没用过 Postman，或者用得不够 6，那就跟我一起探索它的魅力吧！  🤔 什么是 Postman？Postman 是一个强大的 API 开发与测试工具，它可以帮助开发人员和测试人员更高效地与 API 交互。它提供了一个用户友好的界面，让你可以轻松发送请求、检查响应、编写测试脚本，甚至进行自动化测试。  🔥 Postman 的核心优势 简单直观：可视化界面，降低 API 调试难度 支持多种请求类型：GET、POST、PUT、DELETE、PATCH 等 环境变量管理：一键切换不同测试环境，减少手动修改的烦恼 自动化测试：可编写 JavaScript 脚本来自动检查接口响应 接口集合（Collections）：批量管理请求，提高工作效率 Mock 服务：模拟 API 响应，适用于前端开发调试 团队协作：共享 API 文档、测试用例，提高团队协作效率   🚀 1. 安装...</div></div></div></a><a class="pagination-related" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Test-Automation-Tool-Development/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%93%E7%B3%BB-Automation-Testing-System/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-Test-Framework-Design/2025-06-30-pytest/" title="🧪pytest 自动化测试框架学习笔记｜结合两个优质视频总结"><img class="cover" src="/img/pytest.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-30</div><div class="info-item-2">🧪pytest 自动化测试框架学习笔记｜结合两个优质视频总结</div></div><div class="info-2"><div class="info-item-1">🧪pytest 自动化测试框架学习笔记｜结合两个优质视频总结 本文是我基于两个 B 站教学视频的混合学习笔记总结而成：  🎥 白月黑羽编程 Pytest 自动化测试框架 🎥 码尚教育 Pytest 自动化实战全流程  第一部视频讲解简洁清晰，适合快速入门；第二部内容更系统，涵盖 YAML、Allure、关键字驱动等进阶技巧。为避免重复，我将两个视频内容合理整合，输出这份系统化的 Pytest 学习笔记与实战指南，适合初学者查阅，也适合有经验的测试人员查漏补缺。   📌 一、Pytest 框架简介与核心优势Pytest 是 Python 中最流行的单元测试框架之一，也是许多接口自动化框架的基础组件。 核心特点：  ✅ 语法简洁：用 assert 就能断言 ✅ 自动发现用例：命名规则清晰 ✅ 插件丰富：支持 HTML 报告、多线程执行、失败重试等 ✅ 数据驱动支持：原生支持 @pytest.mark.parametrize ✅ 兼容 unittest，支持灵活前后置处理（fixture）   🚀 二、Pytest 基础实战与项目规范✅ 1. 用例编写与命名规则#...</div></div></div></a><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C-Testing-Practices-Case-Studies/%E6%B5%8B%E8%AF%95%E7%BB%8F%E9%AA%8C%E4%B8%8E%E8%90%BD%E5%9C%B0-Testing-Experience/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%BA%94%E7%94%A8-Test-Tool-Application/2025-05-15-apifox/" title="🚀 Apifox 使用指南 —— 开发 &amp; 测试的效率神器"><img class="cover" src="/img/apifox.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-15</div><div class="info-item-2">🚀 Apifox 使用指南 —— 开发 &amp; 测试的效率神器</div></div><div class="info-2"><div class="info-item-1">🚀 Apifox 使用指南 —— 开发 &amp; 测试的效率神器🎉 前言作为测试工程师，我们每天和 API 打交道，而 Apifox 绝对是接口测试界的“全能战士”！ 它不仅可以 发送 API 请求、管理接口文档、生成 Mock 数据、进行自动化测试，还能一键同步接口数据，让开发和测试效率翻倍！ 在上一期《📨 Postman 使用指南 —— 测试工程师的快乐源泉》中，我们介绍了 Postman 作为 API 测试工具的强大功能。今天，我们来看看 Apifox 如何进一步提升效率，并对比它们的不同之处！  🤔 什么是 Apifox？Apifox &#x3D; Postman（接口测试） + Swagger（接口文档） + Mock（模拟数据） + JMeter（接口自动化测试） 是不是听着就很酷？它把接口相关的工作全都集成到了一起，避免了 Postman 只能测，Swagger 只能写文档的尴尬局面。 🔥 Apifox vs. Postman   特性 Apifox Postman    接口测试 ✅ ✅   接口文档 ✅ ❌   Mock...</div></div></div></a><a class="pagination-related" href="/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98%E4%B8%8E%E6%A1%88%E4%BE%8B%E7%BB%8F%E9%AA%8C-Testing-Practices-Case-Studies/%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3-Issues-Solutions/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E4%B8%8E%E6%9F%A5%E8%AF%A2-Log-Analysis-Query/2025-07-28-logcat-guide-for-testers/" title="Logcat 日志详解与测试工程师实战指南"><img class="cover" src="/img/logcat-guide.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-28</div><div class="info-item-2">Logcat 日志详解与测试工程师实战指南</div></div><div class="info-2"><div class="info-item-1">Logcat 日志详解与测试工程师实战指南 适用人群：Android 测试工程师、开发工程师、自动化平台构建者、产品支持人员关键词：Logcat、日志等级、日志过滤、异常排查、自动化测试、日志分析   📌 一、Logcat 是什么？它记录了什么？Logcat 是 Android 提供的系统级日志收集与输出工具，其日志来源可以分为：    类型 示例 说明    应用日志 Log.d(&quot;Login&quot;, &quot;Token missing&quot;) 由开发者主动打的调试信息   系统日志 ActivityManager, WindowManager 系统服务相关日志   崩溃日志 FATAL EXCEPTION 应用在运行时的 Java&#x2F;Kotlin 崩溃堆栈   ANR 日志 ActivityManager: ANR in ... 应用无响应（UI线程被阻塞）事件   GC 回收日志 GC_CONCURRENT, GC_FOR_ALLOC 内存垃圾回收操作及耗时   电池&#x2F;网络&#x2F;传感器等 BatteryStats,...</div></div></div></a><a class="pagination-related" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Test-Automation-Tool-Development/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%93%E7%B3%BB-Automation-Testing-System/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-Test-Framework-Design/2025-10-01-pytest-automation-testing-guide/" title="🚀 Pytest自动化测试框架入门到实战：我的学习笔记与实战经验"><img class="cover" src="/img/pytest.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-01</div><div class="info-item-2">🚀 Pytest自动化测试框架入门到实战：我的学习笔记与实战经验</div></div><div class="info-2"><div class="info-item-1">🚀 Pytest自动化测试框架入门到实战：我的学习笔记与实战经验😊 大家好！最近我系统学习了pytest自动化测试框架！作为一名测试工程师，掌握一个高效的测试框架对提高工作效率至关重要。今天我就把这段时间的学习笔记和实战经验整理出来，希望能帮助到正在学习或准备学习自动化测试的朋友们！ 📚 本文基于白月黑羽编程的pytest自动化测试框架系列课程，强烈推荐给想系统学习的同学：  视频课程：pytest自动化测试框架 - 哔哩哔哩 图文教程：pytest框架 - 白月黑羽官网  🌟 一、为什么选择Pytest？在开始学习之前，我也对比了市面上几种主流的Python测试框架，最终选择pytest是因为它真的太香了！ ✅...</div></div></div></a><a class="pagination-related" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Test-Automation-Tool-Development/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%BD%93%E7%B3%BB-Automation-Testing-System/%E6%B5%8B%E8%AF%95%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1-Test-Framework-Design/2025-10-02-pytest-courses-comparison/" title="📚 pytest学习指南：白月黑羽vs码尚教育课程对比与学习策略"><img class="cover" src="/img/pytest.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-02</div><div class="info-item-2">📚 pytest学习指南：白月黑羽vs码尚教育课程对比与学习策略</div></div><div class="info-2"><div class="info-item-1">📚 pytest学习指南：白月黑羽vs码尚教育课程对比与学习策略👋 大家好！最近我连续学习了两门关于pytest自动化测试框架的课程：白月黑羽的pytest系列教程和码尚教育的pytest自动化测试框架课程。通过对比学习，我发现这两门课程各有特色和优势，如果能够结合学习，可以更全面、更深入地掌握pytest。今天我就来详细对比这两门课程，并分享如何高效结合学习的策略！ 📊 一、课程概览与对比🔍 课程基本信息   对比项 白月黑羽pytest课程 码尚教育pytest课程    课程类型 视频+图文教程 视频教程   内容时长 相对较长，内容全面 中等长度，侧重实战   课程链接 哔哩哔哩 哔哩哔哩   官网支持 提供配套练习环境和代码下载 主要通过B站视频学习   更新频率 定期更新，保持内容新鲜 根据Python版本更新   🎯 课程侧重点对比白月黑羽课程特点✅ 循序渐进：从最基础的概念开始，一步步引导学习者入门✅ 系统全面：涵盖从安装配置到高级功能的所有知识点✅ 实例丰富：提供大量贴近实际项目的案例✅ 配套资源：有详细的图文教程和配套练习题✅...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="utterances-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/ loading='lazy'></div><div class="author-info-name">yuxiaoling</div><div class="author-info-description">分享软件测试学习、实战经验和踩坑历程</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">58</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">217</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">44</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Linn0813"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/Linn0813" target="_blank" title="GitHub"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:yuxiaoling.yxl@qq.com" target="_blank" title="Email"><i class="fa fa-envelope-open-text"></i></a><a class="social-icon" href="javascript:alert('微信公众号：Linn的技术笔记')" target="_blank" title="微信"><i class="fab fa-weixin"></i></a><a class="social-icon" href="https://weibo.com/Linn0813" target="_blank" title="微博"><i class="fab fa-weibo"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">下雨就不想上班</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%90-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%9A%84%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%88%86%E7%B1%BB"><span class="toc-number">1.</span> <span class="toc-text">🌐 接口测试的简介与分类</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9D%93-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">❓ 什么是接口测试？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%82-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">📂 接口测试分类：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%81-%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%9A%84%E6%B5%81%E7%A8%8B%E4%B8%8E%E7%94%A8%E4%BE%8B%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text">🔁 接口测试的流程与用例设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%EF%B8%8F%E2%83%A3-%E7%86%9F%E6%82%89%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.0.1.</span> <span class="toc-text">1️⃣ 熟悉接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%EF%B8%8F%E2%83%A3-%E7%BC%96%E5%86%99%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">2.0.2.</span> <span class="toc-text">2️⃣ 编写接口测试用例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%EF%B8%8F%E2%83%A3-%E6%89%A7%E8%A1%8C%E6%8E%A5%E5%8F%A3%E6%B5%8B%E8%AF%95"><span class="toc-number">2.0.3.</span> <span class="toc-text">3️⃣ 执行接口测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%EF%B8%8F%E2%83%A3-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90"><span class="toc-number">2.0.4.</span> <span class="toc-text">4️⃣ 持续集成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%B0-Postman-%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.</span> <span class="toc-text">🧰 Postman 简介与介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%95%8C%E9%9D%A2%E8%AF%B4%E6%98%8E"><span class="toc-number">3.1.</span> <span class="toc-text">界面说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.</span> <span class="toc-text">请求页面说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E9%A1%B5%E7%AD%BE%E8%AF%B4%E6%98%8E"><span class="toc-number">3.3.</span> <span class="toc-text">响应页签说明</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Get%E8%AF%B7%E6%B1%82%E5%92%8CPost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text">Get请求和Post请求的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text">环境变量与全局变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%85%B3%E8%81%94"><span class="toc-number">6.</span> <span class="toc-text">接口关联</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JSON-%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-number">6.0.1.</span> <span class="toc-text">JSON 提取器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8F%90%E5%8F%96%E5%99%A8"><span class="toc-number">6.0.2.</span> <span class="toc-text">正则表达式提取器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E2%9A%A1-%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">⚡ 动态参数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F%E7%B1%BB-%E2%8F%B0"><span class="toc-number">7.0.1.</span> <span class="toc-text">1. 时间与日期类 ⏰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE%E7%B1%BB-%F0%9F%8E%B2"><span class="toc-number">7.0.2.</span> <span class="toc-text">2. 随机数据类 🎲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E7%B1%BB-%F0%9F%A7%AA"><span class="toc-number">7.0.3.</span> <span class="toc-text">3. 模拟数据类 🧪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">7.0.4.</span> <span class="toc-text">自定义动态参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%8A-Postman-%E6%96%AD%E8%A8%80"><span class="toc-number">8.</span> <span class="toc-text">📊 Postman 断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E5%85%AD%E7%A7%8D%E6%96%AD%E8%A8%80"><span class="toc-number">8.1.</span> <span class="toc-text">常规六种断言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Status-code%EF%BC%9ACode-is-200%EF%BC%88%E7%8A%B6%E6%80%81%E7%A0%81%E6%96%AD%E8%A8%80%EF%BC%89%E2%9C%85"><span class="toc-number">8.1.1.</span> <span class="toc-text">1. Status code：Code is 200（状态码断言）✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Responsebody%EF%BC%9AContains-string%EF%BC%88%E5%93%8D%E5%BA%94%E4%BD%93%E5%8C%85%E5%90%AB%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%94%8D"><span class="toc-number">8.1.2.</span> <span class="toc-text">2. Responsebody：Contains string（响应体包含字符串断言）🔍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Responsebody%EF%BC%9AJson-value-check%EF%BC%88JSON-%E5%80%BC%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%A7%BE"><span class="toc-number">8.1.3.</span> <span class="toc-text">3. Responsebody：Json value check（JSON 值断言）🧾</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Responsebody%EF%BC%9Ais-equal-to-a-string%EF%BC%88%E5%93%8D%E5%BA%94%E4%BD%93%E7%AD%89%E4%BA%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%93%8F"><span class="toc-number">8.1.4.</span> <span class="toc-text">4. Responsebody：is equal to a string（响应体等于字符串断言）📏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Response-headers%EF%BC%9AContent-Type%E2%80%A6%EF%BC%88%E5%93%8D%E5%BA%94%E5%A4%B4%E6%96%AD%E8%A8%80%EF%BC%89%F0%9F%93%8B"><span class="toc-number">8.1.5.</span> <span class="toc-text">5. Response headers：Content-Type…（响应头断言）📋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Response-time-is-less-than-200ms%EF%BC%88%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E6%96%AD%E8%A8%80%EF%BC%89%E2%8F%B1%EF%B8%8F"><span class="toc-number">8.1.6.</span> <span class="toc-text">6. Response time is less than 200ms（响应时间断言）⏱️</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%A7-%E5%9C%A8%E6%96%AD%E8%A8%80%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text">🔧 在断言中获取自定义动态参数的方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%8D-%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80"><span class="toc-number">10.</span> <span class="toc-text">🌍 全局断言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88"><span class="toc-number">10.1.</span> <span class="toc-text">实现全局断言的三种方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-1%EF%BC%9A%E5%9C%A8-Collection-%E4%B8%AD%E7%BC%96%E5%86%99%E5%85%AC%E5%85%B1%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="toc-number">10.1.1.</span> <span class="toc-text">方案 1：在 Collection 中编写公共测试脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%89%8D%E7%BD%AE%E8%84%9A%E6%9C%AC%EF%BC%88Pre-request-Script%EF%BC%89%E5%8A%A8%E6%80%81%E6%B3%A8%E5%85%A5%E6%96%AD%E8%A8%80"><span class="toc-number">10.1.2.</span> <span class="toc-text">方案 2：使用前置脚本（Pre-request Script）动态注入断言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88-3%EF%BC%9A%E9%80%9A%E8%BF%87-Newman-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%B7%BB%E5%8A%A0%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80"><span class="toc-number">10.1.3.</span> <span class="toc-text">方案 3：通过 Newman 命令行添加全局断言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%96%AD%E8%A8%80%E4%B8%8E%E5%B1%80%E9%83%A8%E6%96%AD%E8%A8%80%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%8E%A7%E5%88%B6"><span class="toc-number">10.2.</span> <span class="toc-text">全局断言与局部断言的优先级控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%AA-Postman-%E6%89%B9%E9%87%8F%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B"><span class="toc-number">11.</span> <span class="toc-text">🧪 Postman 批量运行测试用例</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E9%9B%86%E5%90%88%E5%92%8C%E7%BB%84%E7%BB%87%E7%94%A8%E4%BE%8B"><span class="toc-number">11.1.</span> <span class="toc-text">1. 创建集合和组织用例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%89%E6%8B%A9%E8%BF%90%E8%A1%8C%E6%96%B9%E5%BC%8F"><span class="toc-number">11.1.1.</span> <span class="toc-text">2. 选择运行方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%85%8D%E7%BD%AE-Runner-%E5%8F%82%E6%95%B0"><span class="toc-number">11.1.2.</span> <span class="toc-text">3. 配置 Runner 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%89%A7%E8%A1%8C%E6%89%B9%E9%87%8F%E6%B5%8B%E8%AF%95"><span class="toc-number">11.1.3.</span> <span class="toc-text">4. 执行批量测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%86%E6%9E%90%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">11.1.4.</span> <span class="toc-text">5. 分析运行结果</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%93%82-Postman-%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95"><span class="toc-number">12.</span> <span class="toc-text">📂 Postman 数据驱动测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-CSV-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">12.1.</span> <span class="toc-text">✅ CSV 参数化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%81-CSV-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82"><span class="toc-number">12.1.1.</span> <span class="toc-text">📁 CSV 文件格式要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A5-%E5%AF%BC%E5%85%A5-CSV-%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.1.2.</span> <span class="toc-text">📥 导入 CSV 步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%97-%E8%AF%B7%E6%B1%82%E4%B8%AD%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">12.1.3.</span> <span class="toc-text">🔗 请求中引用变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-JSON-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">12.2.</span> <span class="toc-text">✅ JSON 参数化测试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%81-JSON-%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A6%81%E6%B1%82"><span class="toc-number">12.2.1.</span> <span class="toc-text">📁 JSON 文件格式要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%93%A5-%E5%AF%BC%E5%85%A5-JSON-%E6%AD%A5%E9%AA%A4"><span class="toc-number">12.2.2.</span> <span class="toc-text">📥 导入 JSON 步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%97-%E5%BC%95%E7%94%A8%E6%96%B9%E5%BC%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.2.3.</span> <span class="toc-text">🔗 引用方式示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%BE-%E8%AF%B7%E6%B1%82%E5%BF%85%E9%A1%BB%E6%90%BA%E5%B8%A6%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E8%AF%B4%E6%98%8E"><span class="toc-number">13.</span> <span class="toc-text">🧾 请求必须携带的请求头说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%A7-Postman%E6%8E%A5%E5%8F%A3Mock-Servier%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">14.</span> <span class="toc-text">🔧 Postman接口Mock Servier服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AA-Mock-Server-%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.1.</span> <span class="toc-text">🧪 Mock Server 核心价值与应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="toc-number">14.1.1.</span> <span class="toc-text">核心价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.1.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E5%88%9B%E5%BB%BA-Mock-Server-%E5%85%A8%E6%B5%81%E7%A8%8B%EF%BC%88%E4%BB%A5%E7%94%A8%E6%88%B7%E7%A4%BA%E4%BE%8B%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">14.2.</span> <span class="toc-text">⚙️ 创建 Mock Server 全流程（以用户示例为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%87%86%E5%A4%87-Mock-%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE"><span class="toc-number">14.2.1.</span> <span class="toc-text">1. 准备 Mock 响应数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9C%A8-Postman-%E4%B8%AD%E5%88%9B%E5%BB%BA-Mock-Server"><span class="toc-number">14.2.2.</span> <span class="toc-text">2. 在 Postman 中创建 Mock Server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%89%8D%E7%AB%AF%E8%B0%83%E7%94%A8-Mock-%E6%8E%A5%E5%8F%A3%E7%A4%BA%E4%BE%8B%EF%BC%88JavaScript%EF%BC%89"><span class="toc-number">14.2.3.</span> <span class="toc-text">3. 前端调用 Mock 接口示例（JavaScript）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8D%AA-Postman-%E7%9A%84-Cookie-%E9%89%B4%E6%9D%83%E6%9C%BA%E5%88%B6"><span class="toc-number">15.</span> <span class="toc-text">🍪 Postman 的 Cookie 鉴权机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Cookie-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">15.1.</span> <span class="toc-text">1. Cookie 是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%89%B4%E6%9D%83%E6%B5%81%E7%A8%8B"><span class="toc-number">15.2.</span> <span class="toc-text">2. 鉴权流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Cookie-%E7%B1%BB%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">15.2.1.</span> <span class="toc-text">3. Cookie 类型对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%94%90-Postman-%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86"><span class="toc-number">16.</span> <span class="toc-text">🔐 Postman 实现接口加密与解密</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%88%86%E7%B1%BB"><span class="toc-number">16.1.</span> <span class="toc-text">主流加密算法分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Postman-%E4%B8%AD%E5%8A%A0%E5%AF%86%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">16.2.</span> <span class="toc-text">Postman 中加密实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E4%BD%BF%E7%94%A8%E5%86%85%E7%BD%AE-CryptoJS%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">16.2.1.</span> <span class="toc-text">✅ 使用内置 CryptoJS（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-%E5%A4%96%E9%83%A8-JS-%E6%96%87%E4%BB%B6%E5%AF%BC%E5%85%A5"><span class="toc-number">16.2.2.</span> <span class="toc-text">🔄 外部 JS 文件导入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E8%A7%A3%E5%AF%86%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%EF%BC%88Tests-%E8%84%9A%E6%9C%AC%E4%B8%AD%EF%BC%89"><span class="toc-number">16.3.</span> <span class="toc-text">🔍 解密响应数据（Tests 脚本中）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-Tests-%E8%84%9A%E6%9C%AC%E4%B8%AD%E8%A7%A3%E5%AF%86%E5%93%8D%E5%BA%94"><span class="toc-number">16.3.1.</span> <span class="toc-text">在 Tests 脚本中解密响应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C"><span class="toc-number">16.3.2.</span> <span class="toc-text">使用环境变量存储解密结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%90-%E5%8A%A0%E5%AF%86%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B"><span class="toc-number">16.4.</span> <span class="toc-text">🔐 加密场景示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%9A%80-Newman"><span class="toc-number">17.</span> <span class="toc-text">🚀 Newman</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%80-Newman-%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC%E4%B8%8E%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">17.1.</span> <span class="toc-text">🚀 Newman 核心价值与应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9B%A0-Newman-%E5%AE%89%E8%A3%85%E4%B8%8E%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">17.2.</span> <span class="toc-text">🛠 Newman 安装与基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">17.2.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4%E7%BB%93%E6%9E%84"><span class="toc-number">17.2.2.</span> <span class="toc-text">基础命令结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">17.2.3.</span> <span class="toc-text">核心参数说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8F%83%E2%80%8D%E2%99%82%EF%B8%8F-%E4%BB%8E-Postman-%E5%88%B0-Newman-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">17.3.</span> <span class="toc-text">🏃‍♂️ 从 Postman 到 Newman 的完整流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%BC%E5%87%BA-Collection-%E5%92%8C-Environment"><span class="toc-number">17.3.1.</span> <span class="toc-text">1. 导出 Collection 和 Environment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E5%9F%BA%E6%9C%AC%E6%B5%8B%E8%AF%95"><span class="toc-number">17.3.2.</span> <span class="toc-text">2. 执行基本测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%82%E6%95%B0%E5%8C%96%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-number">17.3.3.</span> <span class="toc-text">3. 参数化测试示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E7%A4%BA%E4%BE%8B"><span class="toc-number">17.3.4.</span> <span class="toc-text">4. 并发与全局变量示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A4%96-Postman-Newman-Jenkins-%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%88%98"><span class="toc-number">18.</span> <span class="toc-text">🤖 Postman + Newman + Jenkins 持续集成实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%AD%A5%E9%AA%A4%E9%80%9F%E8%A7%88"><span class="toc-number">18.1.</span> <span class="toc-text">核心步骤速览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%96%A5-%E8%AF%A6%E7%BB%86%E6%93%8D%E4%BD%9C%E6%AD%A5%E9%AA%A4"><span class="toc-number">18.2.</span> <span class="toc-text">🖥 详细操作步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">18.2.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jenkins-%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE"><span class="toc-number">18.2.2.</span> <span class="toc-text">Jenkins 项目配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%8D-%E5%85%B3%E9%94%AE%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90"><span class="toc-number">18.3.</span> <span class="toc-text">🔍 关键命令解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%A0%EF%B8%8F-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">18.4.</span> <span class="toc-text">⚠️ 常见问题及解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%89%A7%E8%A1%8C%E6%95%88%E6%9E%9C%E9%AA%8C%E8%AF%81"><span class="toc-number">18.5.</span> <span class="toc-text">✅ 执行效果验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%9C%A8%E6%9C%80%E5%90%8E"><span class="toc-number">18.6.</span> <span class="toc-text">写在最后</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/AI%E4%B8%8E%E7%A0%94%E7%A9%B6-AI-Research/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B-Prompt-Engineering/2025-10-27-langchain-framework/" title="🧠 LangChain：让大语言模型真正“动起来”的框架"><img src="/img/langchain.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🧠 LangChain：让大语言模型真正“动起来”的框架"/ loading='lazy'></a><div class="content"><a class="title" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/AI%E4%B8%8E%E7%A0%94%E7%A9%B6-AI-Research/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B-Prompt-Engineering/2025-10-27-langchain-framework/" title="🧠 LangChain：让大语言模型真正“动起来”的框架">🧠 LangChain：让大语言模型真正“动起来”的框架</a><time datetime="2025-10-27T11:00:00.000Z" title="发表于 2025-10-27 19:00:00">2025-10-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/AI%E4%B8%8E%E7%A0%94%E7%A9%B6-AI-Research/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B-Prompt-Engineering/2025-10-24-mind-your-tone/" title="🧩 Mind Your Tone：为什么我们不必再对 AI 太客气"><img src="/img/Mind-Your-Tone.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🧩 Mind Your Tone：为什么我们不必再对 AI 太客气"/ loading='lazy'></a><div class="content"><a class="title" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/AI%E4%B8%8E%E7%A0%94%E7%A9%B6-AI-Research/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B-Prompt-Engineering/2025-10-24-mind-your-tone/" title="🧩 Mind Your Tone：为什么我们不必再对 AI 太客气">🧩 Mind Your Tone：为什么我们不必再对 AI 太客气</a><time datetime="2025-10-24T11:00:00.000Z" title="发表于 2025-10-24 19:00:00">2025-10-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/AI%E4%B8%8E%E7%A0%94%E7%A9%B6-AI-Research/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B-Prompt-Engineering/2025-10-21-llm-agent-guide/" title="🧠 LLM 与智能体（Agent）知识记录"><img src="/img/LLM-Agent.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🧠 LLM 与智能体（Agent）知识记录"/ loading='lazy'></a><div class="content"><a class="title" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/AI%E4%B8%8E%E7%A0%94%E7%A9%B6-AI-Research/%E6%8F%90%E7%A4%BA%E5%B7%A5%E7%A8%8B-Prompt-Engineering/2025-10-21-llm-agent-guide/" title="🧠 LLM 与智能体（Agent）知识记录">🧠 LLM 与智能体（Agent）知识记录</a><time datetime="2025-10-21T13:00:00.000Z" title="发表于 2025-10-21 21:00:00">2025-10-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Test-Automation-Tool-Development/%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91-Tools-Platform-Development/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Test-Tool-Development/2025-10-15-coze-testcase-assistant/" title="🤖 手把手教你用Coze打造专属测试用例编写助手"><img src="/img/coze-testcase-assistant.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="🤖 手把手教你用Coze打造专属测试用例编写助手"/ loading='lazy'></a><div class="content"><a class="title" href="/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E4%B8%8E%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Test-Automation-Tool-Development/%E5%B7%A5%E5%85%B7%E4%B8%8E%E5%B9%B3%E5%8F%B0%E5%BC%80%E5%8F%91-Tools-Platform-Development/%E6%B5%8B%E8%AF%95%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91-Test-Tool-Development/2025-10-15-coze-testcase-assistant/" title="🤖 手把手教你用Coze打造专属测试用例编写助手">🤖 手把手教你用Coze打造专属测试用例编写助手</a><time datetime="2025-10-15T15:00:00.000Z" title="发表于 2025-10-15 23:00:00">2025-10-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/%E5%BC%80%E5%8F%91%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%A0%88-Development-Tech-Stack/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-Backend-Development/2025-10-14-serialization-deep-dive/" title="深入理解「可序列化」：开发与测试都绕不开的隐形规则"><img src="/img/serialization-deep-dive.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="深入理解「可序列化」：开发与测试都绕不开的隐形规则"/ loading='lazy'></a><div class="content"><a class="title" href="/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0%E4%B8%8E%E8%A1%8C%E4%B8%9A%E8%B6%8B%E5%8A%BF-Learning-Industry-Trends/%E5%BC%80%E5%8F%91%E4%B8%8E%E6%8A%80%E6%9C%AF%E6%A0%88-Development-Tech-Stack/%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91-Backend-Development/2025-10-14-serialization-deep-dive/" title="深入理解「可序列化」：开发与测试都绕不开的隐形规则">深入理解「可序列化」：开发与测试都绕不开的隐形规则</a><time datetime="2025-10-13T17:00:00.000Z" title="发表于 2025-10-14 01:00:00">2025-10-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2025 By yuxiaoling</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null
  const getUtterancesTheme = theme => theme === 'dark' ? 'photon-dark' : 'github-light'

  const loadUtterances = (el = document, key) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyUtterances = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const config = {
      src: 'https://utteranc.es/client.js',
      repo: 'Linn0813/Linn0813.github.io',
      theme: getUtterancesTheme(document.documentElement.getAttribute('data-theme')),
      crossorigin: 'anonymous',
      async: true,
      ...option,
      'issue-term': isShuoshuo ? key : (option && option['issue-term']) || 'pathname'
    }

    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => ele.setAttribute(key, value))
    el.querySelector('#utterances-wrap').appendChild(ele)
  }

  const changeUtterancesTheme = theme => {
    const iframe = document.querySelector('#utterances-wrap iframe')
    if (iframe) {
      const message = {
        type: 'set-theme',
        theme: getUtterancesTheme(theme)
      };
      iframe.contentWindow.postMessage(message, 'https://utteranc.es')
    }
  }

  btf.addGlobalFn('themeChange', changeUtterancesTheme, 'utterances')

  if (isShuoshuo) {
    'Utterances' === 'Utterances'
      ? window.shuoshuoComment = { loadComment: loadUtterances }
      : window.loadOtherComment = loadUtterances
    return
  }
  
  if ('Utterances' === 'Utterances' || !false) {
    if (false) btf.loadComment(document.getElementById('utterances-wrap'), loadUtterances)
    else loadUtterances()
  } else {
    window.loadOtherComment = loadUtterances
  }
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>